// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpc/grpc/proto3/blockchain.proto

package proto3

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/struct"

import github_com_gallactic_gallactic_core_account "github.com/gallactic/gallactic/core/account"
import github_com_gallactic_gallactic_core_validator "github.com/gallactic/gallactic/core/validator"
import github_com_gallactic_gallactic_crypto "github.com/gallactic/gallactic/crypto"
import github_com_gallactic_gallactic_common_binary "github.com/gallactic/gallactic/common/binary"
import github_com_tendermint_tendermint_consensus_types "github.com/tendermint/tendermint/consensus/types"
import github_com_tendermint_tendermint_p2p "github.com/tendermint/tendermint/p2p"
import github_com_tendermint_tendermint_types "github.com/tendermint/tendermint/types"
import github_com_gallactic_gallactic_core_proposal "github.com/gallactic/gallactic/core/proposal"
import github_com_gallactic_gallactic_txs "github.com/gallactic/gallactic/txs"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func (*Empty) XXX_MessageName() string {
	return "proto3.Empty"
}

type AccountsResponse struct {
	BlockHeight          uint64             `protobuf:"varint,1,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	Accounts             []*AccountResponse `protobuf:"bytes,2,rep,name=Accounts" json:"Accounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AccountsResponse) Reset()         { *m = AccountsResponse{} }
func (m *AccountsResponse) String() string { return proto.CompactTextString(m) }
func (*AccountsResponse) ProtoMessage()    {}
func (*AccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{1}
}
func (m *AccountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AccountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountsResponse.Merge(dst, src)
}
func (m *AccountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *AccountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AccountsResponse proto.InternalMessageInfo

func (m *AccountsResponse) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *AccountsResponse) GetAccounts() []*AccountResponse {
	if m != nil {
		return m.Accounts
	}
	return nil
}

func (*AccountsResponse) XXX_MessageName() string {
	return "proto3.AccountsResponse"
}

type AccountResponse struct {
	Account              *github_com_gallactic_gallactic_core_account.Account `protobuf:"bytes,1,opt,name=Account,customtype=github.com/gallactic/gallactic/core/account.Account" json:"Account,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                             `json:"-"`
	XXX_unrecognized     []byte                                               `json:"-"`
	XXX_sizecache        int32                                                `json:"-"`
}

func (m *AccountResponse) Reset()         { *m = AccountResponse{} }
func (m *AccountResponse) String() string { return proto.CompactTextString(m) }
func (*AccountResponse) ProtoMessage()    {}
func (*AccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{2}
}
func (m *AccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountResponse.Merge(dst, src)
}
func (m *AccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *AccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AccountResponse proto.InternalMessageInfo

func (*AccountResponse) XXX_MessageName() string {
	return "proto3.AccountResponse"
}

type ValidatorResponse struct {
	Validator            *github_com_gallactic_gallactic_core_validator.Validator `protobuf:"bytes,1,opt,name=Validator,customtype=github.com/gallactic/gallactic/core/validator.Validator" json:"Validator,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                 `json:"-"`
	XXX_unrecognized     []byte                                                   `json:"-"`
	XXX_sizecache        int32                                                    `json:"-"`
}

func (m *ValidatorResponse) Reset()         { *m = ValidatorResponse{} }
func (m *ValidatorResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorResponse) ProtoMessage()    {}
func (*ValidatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{3}
}
func (m *ValidatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ValidatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorResponse.Merge(dst, src)
}
func (m *ValidatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorResponse proto.InternalMessageInfo

func (*ValidatorResponse) XXX_MessageName() string {
	return "proto3.ValidatorResponse"
}

type ValidatorsResponse struct {
	BlockHeight          uint64               `protobuf:"varint,1,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	Validators           []*ValidatorResponse `protobuf:"bytes,2,rep,name=Validators" json:"Validators,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ValidatorsResponse) Reset()         { *m = ValidatorsResponse{} }
func (m *ValidatorsResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorsResponse) ProtoMessage()    {}
func (*ValidatorsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{4}
}
func (m *ValidatorsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ValidatorsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorsResponse.Merge(dst, src)
}
func (m *ValidatorsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorsResponse proto.InternalMessageInfo

func (m *ValidatorsResponse) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ValidatorsResponse) GetValidators() []*ValidatorResponse {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (*ValidatorsResponse) XXX_MessageName() string {
	return "proto3.ValidatorsResponse"
}

type ListAccountsParam struct {
	Query                string   `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAccountsParam) Reset()         { *m = ListAccountsParam{} }
func (m *ListAccountsParam) String() string { return proto.CompactTextString(m) }
func (*ListAccountsParam) ProtoMessage()    {}
func (*ListAccountsParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{5}
}
func (m *ListAccountsParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAccountsParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAccountsParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListAccountsParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAccountsParam.Merge(dst, src)
}
func (m *ListAccountsParam) XXX_Size() int {
	return m.Size()
}
func (m *ListAccountsParam) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAccountsParam.DiscardUnknown(m)
}

var xxx_messageInfo_ListAccountsParam proto.InternalMessageInfo

func (m *ListAccountsParam) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (*ListAccountsParam) XXX_MessageName() string {
	return "proto3.ListAccountsParam"
}

type AddressRequest struct {
	Address              github_com_gallactic_gallactic_crypto.Address `protobuf:"bytes,1,opt,name=Address,proto3,customtype=github.com/gallactic/gallactic/crypto.Address" json:"Address"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *AddressRequest) Reset()         { *m = AddressRequest{} }
func (m *AddressRequest) String() string { return proto.CompactTextString(m) }
func (*AddressRequest) ProtoMessage()    {}
func (*AddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{6}
}
func (m *AddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressRequest.Merge(dst, src)
}
func (m *AddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddressRequest proto.InternalMessageInfo

func (*AddressRequest) XXX_MessageName() string {
	return "proto3.AddressRequest"
}

type StorageAtRequest struct {
	Address              github_com_gallactic_gallactic_crypto.Address         `protobuf:"bytes,1,opt,name=Address,proto3,customtype=github.com/gallactic/gallactic/crypto.Address" json:"Address"`
	Key                  github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,2,opt,name=Key,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"Key"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *StorageAtRequest) Reset()         { *m = StorageAtRequest{} }
func (m *StorageAtRequest) String() string { return proto.CompactTextString(m) }
func (*StorageAtRequest) ProtoMessage()    {}
func (*StorageAtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{7}
}
func (m *StorageAtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageAtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageAtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StorageAtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageAtRequest.Merge(dst, src)
}
func (m *StorageAtRequest) XXX_Size() int {
	return m.Size()
}
func (m *StorageAtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageAtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StorageAtRequest proto.InternalMessageInfo

func (*StorageAtRequest) XXX_MessageName() string {
	return "proto3.StorageAtRequest"
}

type StorageResponse struct {
	Key                  github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,1,opt,name=Key,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"Key"`
	Value                github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,2,opt,name=Value,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"Value"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *StorageResponse) Reset()         { *m = StorageResponse{} }
func (m *StorageResponse) String() string { return proto.CompactTextString(m) }
func (*StorageResponse) ProtoMessage()    {}
func (*StorageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{8}
}
func (m *StorageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StorageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageResponse.Merge(dst, src)
}
func (m *StorageResponse) XXX_Size() int {
	return m.Size()
}
func (m *StorageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StorageResponse proto.InternalMessageInfo

func (*StorageResponse) XXX_MessageName() string {
	return "proto3.StorageResponse"
}

type ConsensusResponse struct {
	RoundState           github_com_tendermint_tendermint_consensus_types.RoundStateSimple `protobuf:"bytes,1,opt,name=RoundState,proto3,customtype=github.com/tendermint/tendermint/consensus/types.RoundStateSimple" json:"RoundState"`
	PeerRoundStates      []github_com_tendermint_tendermint_consensus_types.PeerRoundState `protobuf:"bytes,2,rep,name=PeerRoundStates,customtype=github.com/tendermint/tendermint/consensus/types.PeerRoundState" json:"PeerRoundStates"`
	XXX_NoUnkeyedLiteral struct{}                                                          `json:"-"`
	XXX_unrecognized     []byte                                                            `json:"-"`
	XXX_sizecache        int32                                                             `json:"-"`
}

func (m *ConsensusResponse) Reset()         { *m = ConsensusResponse{} }
func (m *ConsensusResponse) String() string { return proto.CompactTextString(m) }
func (*ConsensusResponse) ProtoMessage()    {}
func (*ConsensusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{9}
}
func (m *ConsensusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusResponse.Merge(dst, src)
}
func (m *ConsensusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusResponse proto.InternalMessageInfo

func (*ConsensusResponse) XXX_MessageName() string {
	return "proto3.ConsensusResponse"
}

type ChainResponse struct {
	ChainName            string                                                `protobuf:"bytes,1,opt,name=ChainName,proto3" json:"ChainName,omitempty"`
	ChainId              string                                                `protobuf:"bytes,2,opt,name=ChainId,proto3" json:"ChainId,omitempty"`
	GenesisHash          github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,3,opt,name=GenesisHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"GenesisHash"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *ChainResponse) Reset()         { *m = ChainResponse{} }
func (m *ChainResponse) String() string { return proto.CompactTextString(m) }
func (*ChainResponse) ProtoMessage()    {}
func (*ChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{10}
}
func (m *ChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainResponse.Merge(dst, src)
}
func (m *ChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChainResponse proto.InternalMessageInfo

func (m *ChainResponse) GetChainName() string {
	if m != nil {
		return m.ChainName
	}
	return ""
}

func (m *ChainResponse) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (*ChainResponse) XXX_MessageName() string {
	return "proto3.ChainResponse"
}

type StatusResponse struct {
	NodeInfo             github_com_tendermint_tendermint_p2p.DefaultNodeInfo  `protobuf:"bytes,1,opt,name=NodeInfo,proto3,customtype=github.com/tendermint/tendermint/p2p.DefaultNodeInfo" json:"NodeInfo"`
	GenesisHash          github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,2,opt,name=GenesisHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"GenesisHash"`
	PubKey               github_com_gallactic_gallactic_crypto.PublicKey       `protobuf:"bytes,3,opt,name=PubKey,proto3,customtype=github.com/gallactic/gallactic/crypto.PublicKey" json:"PubKey"`
	LatestBlockHash      github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,4,opt,name=LatestBlockHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"LatestBlockHash"`
	LatestBlockHeight    uint64                                                `protobuf:"varint,5,opt,name=LatestBlockHeight,proto3" json:"LatestBlockHeight,omitempty"`
	LatestBlockTime      int64                                                 `protobuf:"varint,6,opt,name=LatestBlockTime,proto3" json:"LatestBlockTime,omitempty"`
	NodeVersion          string                                                `protobuf:"bytes,7,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *StatusResponse) Reset()         { *m = StatusResponse{} }
func (m *StatusResponse) String() string { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()    {}
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{11}
}
func (m *StatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusResponse.Merge(dst, src)
}
func (m *StatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatusResponse proto.InternalMessageInfo

func (m *StatusResponse) GetLatestBlockHeight() uint64 {
	if m != nil {
		return m.LatestBlockHeight
	}
	return 0
}

func (m *StatusResponse) GetLatestBlockTime() int64 {
	if m != nil {
		return m.LatestBlockTime
	}
	return 0
}

func (m *StatusResponse) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (*StatusResponse) XXX_MessageName() string {
	return "proto3.StatusResponse"
}

type BlockRequest struct {
	Height               uint64   `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockRequest) Reset()         { *m = BlockRequest{} }
func (m *BlockRequest) String() string { return proto.CompactTextString(m) }
func (*BlockRequest) ProtoMessage()    {}
func (*BlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{12}
}
func (m *BlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRequest.Merge(dst, src)
}
func (m *BlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRequest proto.InternalMessageInfo

func (m *BlockRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (*BlockRequest) XXX_MessageName() string {
	return "proto3.BlockRequest"
}

type BlocksRequest struct {
	MinHeight            uint64   `protobuf:"varint,1,opt,name=minHeight,proto3" json:"minHeight,omitempty"`
	MaxHeight            uint64   `protobuf:"varint,2,opt,name=maxHeight,proto3" json:"maxHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlocksRequest) Reset()         { *m = BlocksRequest{} }
func (m *BlocksRequest) String() string { return proto.CompactTextString(m) }
func (*BlocksRequest) ProtoMessage()    {}
func (*BlocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{13}
}
func (m *BlocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlocksRequest.Merge(dst, src)
}
func (m *BlocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlocksRequest proto.InternalMessageInfo

func (m *BlocksRequest) GetMinHeight() uint64 {
	if m != nil {
		return m.MinHeight
	}
	return 0
}

func (m *BlocksRequest) GetMaxHeight() uint64 {
	if m != nil {
		return m.MaxHeight
	}
	return 0
}

func (*BlocksRequest) XXX_MessageName() string {
	return "proto3.BlocksRequest"
}

type BlockResponse struct {
	BlockMeta            *github_com_tendermint_tendermint_types.BlockMeta `protobuf:"bytes,1,opt,name=BlockMeta,proto3,customtype=github.com/tendermint/tendermint/types.BlockMeta" json:"BlockMeta,omitempty"`
	Block                *github_com_tendermint_tendermint_types.Block     `protobuf:"bytes,2,opt,name=Block,proto3,customtype=github.com/tendermint/tendermint/types.Block" json:"Block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                          `json:"-"`
	XXX_unrecognized     []byte                                            `json:"-"`
	XXX_sizecache        int32                                             `json:"-"`
}

func (m *BlockResponse) Reset()         { *m = BlockResponse{} }
func (m *BlockResponse) String() string { return proto.CompactTextString(m) }
func (*BlockResponse) ProtoMessage()    {}
func (*BlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{14}
}
func (m *BlockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockResponse.Merge(dst, src)
}
func (m *BlockResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockResponse proto.InternalMessageInfo

func (*BlockResponse) XXX_MessageName() string {
	return "proto3.BlockResponse"
}

type BlocksResponse struct {
	LastHeight           uint64                                             `protobuf:"varint,1,opt,name=LastHeight,proto3" json:"LastHeight,omitempty"`
	BlockMeta            []github_com_tendermint_tendermint_types.BlockMeta `protobuf:"bytes,2,rep,name=BlockMeta,customtype=github.com/tendermint/tendermint/types.BlockMeta" json:"BlockMeta,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                           `json:"-"`
	XXX_unrecognized     []byte                                             `json:"-"`
	XXX_sizecache        int32                                              `json:"-"`
}

func (m *BlocksResponse) Reset()         { *m = BlocksResponse{} }
func (m *BlocksResponse) String() string { return proto.CompactTextString(m) }
func (*BlocksResponse) ProtoMessage()    {}
func (*BlocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{15}
}
func (m *BlocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlocksResponse.Merge(dst, src)
}
func (m *BlocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlocksResponse proto.InternalMessageInfo

func (m *BlocksResponse) GetLastHeight() uint64 {
	if m != nil {
		return m.LastHeight
	}
	return 0
}

func (*BlocksResponse) XXX_MessageName() string {
	return "proto3.BlocksResponse"
}

type BlockMeta struct {
	BlockMeta            *github_com_tendermint_tendermint_types.BlockMeta `protobuf:"bytes,1,opt,name=BlockMeta,proto3,customtype=github.com/tendermint/tendermint/types.BlockMeta" json:"BlockMeta,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                          `json:"-"`
	XXX_unrecognized     []byte                                            `json:"-"`
	XXX_sizecache        int32                                             `json:"-"`
}

func (m *BlockMeta) Reset()         { *m = BlockMeta{} }
func (m *BlockMeta) String() string { return proto.CompactTextString(m) }
func (*BlockMeta) ProtoMessage()    {}
func (*BlockMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{16}
}
func (m *BlockMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockMeta.Merge(dst, src)
}
func (m *BlockMeta) XXX_Size() int {
	return m.Size()
}
func (m *BlockMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockMeta.DiscardUnknown(m)
}

var xxx_messageInfo_BlockMeta proto.InternalMessageInfo

func (*BlockMeta) XXX_MessageName() string {
	return "proto3.BlockMeta"
}

type Block struct {
	Block                *github_com_tendermint_tendermint_types.Block `protobuf:"bytes,2,opt,name=Block,proto3,customtype=github.com/tendermint/tendermint/types.Block" json:"Block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{17}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(dst, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (*Block) XXX_MessageName() string {
	return "proto3.Block"
}

type GenesisResponse struct {
	Genesis              *github_com_gallactic_gallactic_core_proposal.Genesis `protobuf:"bytes,1,opt,name=Genesis,customtype=github.com/gallactic/gallactic/core/proposal.Genesis" json:"Genesis,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *GenesisResponse) Reset()         { *m = GenesisResponse{} }
func (m *GenesisResponse) String() string { return proto.CompactTextString(m) }
func (*GenesisResponse) ProtoMessage()    {}
func (*GenesisResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{18}
}
func (m *GenesisResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenesisResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisResponse.Merge(dst, src)
}
func (m *GenesisResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenesisResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisResponse proto.InternalMessageInfo

func (*GenesisResponse) XXX_MessageName() string {
	return "proto3.GenesisResponse"
}

type BlockTxsResponse struct {
	Count                int32                                         `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
	Txs                  []github_com_gallactic_gallactic_txs.Envelope `protobuf:"bytes,3,rep,name=Txs,customtype=github.com/gallactic/gallactic/txs.Envelope" json:"Txs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *BlockTxsResponse) Reset()         { *m = BlockTxsResponse{} }
func (m *BlockTxsResponse) String() string { return proto.CompactTextString(m) }
func (*BlockTxsResponse) ProtoMessage()    {}
func (*BlockTxsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_742c198a80beb388, []int{19}
}
func (m *BlockTxsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockTxsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockTxsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockTxsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockTxsResponse.Merge(dst, src)
}
func (m *BlockTxsResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockTxsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockTxsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockTxsResponse proto.InternalMessageInfo

func (m *BlockTxsResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (*BlockTxsResponse) XXX_MessageName() string {
	return "proto3.BlockTxsResponse"
}
func init() {
	proto.RegisterType((*Empty)(nil), "proto3.Empty")
	proto.RegisterType((*AccountsResponse)(nil), "proto3.AccountsResponse")
	proto.RegisterType((*AccountResponse)(nil), "proto3.AccountResponse")
	proto.RegisterType((*ValidatorResponse)(nil), "proto3.ValidatorResponse")
	proto.RegisterType((*ValidatorsResponse)(nil), "proto3.ValidatorsResponse")
	proto.RegisterType((*ListAccountsParam)(nil), "proto3.ListAccountsParam")
	proto.RegisterType((*AddressRequest)(nil), "proto3.AddressRequest")
	proto.RegisterType((*StorageAtRequest)(nil), "proto3.StorageAtRequest")
	proto.RegisterType((*StorageResponse)(nil), "proto3.StorageResponse")
	proto.RegisterType((*ConsensusResponse)(nil), "proto3.ConsensusResponse")
	proto.RegisterType((*ChainResponse)(nil), "proto3.ChainResponse")
	proto.RegisterType((*StatusResponse)(nil), "proto3.StatusResponse")
	proto.RegisterType((*BlockRequest)(nil), "proto3.BlockRequest")
	proto.RegisterType((*BlocksRequest)(nil), "proto3.BlocksRequest")
	proto.RegisterType((*BlockResponse)(nil), "proto3.BlockResponse")
	proto.RegisterType((*BlocksResponse)(nil), "proto3.BlocksResponse")
	proto.RegisterType((*BlockMeta)(nil), "proto3.BlockMeta")
	proto.RegisterType((*Block)(nil), "proto3.Block")
	proto.RegisterType((*GenesisResponse)(nil), "proto3.GenesisResponse")
	proto.RegisterType((*BlockTxsResponse)(nil), "proto3.BlockTxsResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BlockChainClient is the client API for BlockChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BlockChainClient interface {
	GetAccount(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*AccountResponse, error)
	GetAccounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AccountsResponse, error)
	GetStorage(ctx context.Context, in *StorageAtRequest, opts ...grpc.CallOption) (*StorageResponse, error)
	GetStorageAt(ctx context.Context, in *StorageAtRequest, opts ...grpc.CallOption) (*StorageResponse, error)
	GetValidator(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*ValidatorResponse, error)
	GetValidators(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ValidatorsResponse, error)
	Getstatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponse, error)
	GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	GetBlocks(ctx context.Context, in *BlocksRequest, opts ...grpc.CallOption) (*BlocksResponse, error)
	GetGenesis(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GenesisResponse, error)
	GetChainID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ChainResponse, error)
	GetLatestBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	GetConsensusState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConsensusResponse, error)
	GetBlockTxs(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockTxsResponse, error)
}

type blockChainClient struct {
	cc *grpc.ClientConn
}

func NewBlockChainClient(cc *grpc.ClientConn) BlockChainClient {
	return &blockChainClient{cc}
}

func (c *blockChainClient) GetAccount(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*AccountResponse, error) {
	out := new(AccountResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetAccounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AccountsResponse, error) {
	out := new(AccountsResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetStorage(ctx context.Context, in *StorageAtRequest, opts ...grpc.CallOption) (*StorageResponse, error) {
	out := new(StorageResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetStorage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetStorageAt(ctx context.Context, in *StorageAtRequest, opts ...grpc.CallOption) (*StorageResponse, error) {
	out := new(StorageResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetStorageAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetValidator(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*ValidatorResponse, error) {
	out := new(ValidatorResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetValidators(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ValidatorsResponse, error) {
	out := new(ValidatorsResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) Getstatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/Getstatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetBlocks(ctx context.Context, in *BlocksRequest, opts ...grpc.CallOption) (*BlocksResponse, error) {
	out := new(BlocksResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetGenesis(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GenesisResponse, error) {
	out := new(GenesisResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetGenesis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetChainID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ChainResponse, error) {
	out := new(ChainResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetChainID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetLatestBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetLatestBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetConsensusState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConsensusResponse, error) {
	out := new(ConsensusResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetConsensusState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetBlockTxs(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockTxsResponse, error) {
	out := new(BlockTxsResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetBlockTxs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlockChainServer is the server API for BlockChain service.
type BlockChainServer interface {
	GetAccount(context.Context, *AddressRequest) (*AccountResponse, error)
	GetAccounts(context.Context, *Empty) (*AccountsResponse, error)
	GetStorage(context.Context, *StorageAtRequest) (*StorageResponse, error)
	GetStorageAt(context.Context, *StorageAtRequest) (*StorageResponse, error)
	GetValidator(context.Context, *AddressRequest) (*ValidatorResponse, error)
	GetValidators(context.Context, *Empty) (*ValidatorsResponse, error)
	Getstatus(context.Context, *Empty) (*StatusResponse, error)
	GetBlock(context.Context, *BlockRequest) (*BlockResponse, error)
	GetBlocks(context.Context, *BlocksRequest) (*BlocksResponse, error)
	GetGenesis(context.Context, *Empty) (*GenesisResponse, error)
	GetChainID(context.Context, *Empty) (*ChainResponse, error)
	GetLatestBlock(context.Context, *BlockRequest) (*BlockResponse, error)
	GetConsensusState(context.Context, *Empty) (*ConsensusResponse, error)
	GetBlockTxs(context.Context, *BlockRequest) (*BlockTxsResponse, error)
}

func RegisterBlockChainServer(s *grpc.Server, srv BlockChainServer) {
	s.RegisterService(&_BlockChain_serviceDesc, srv)
}

func _BlockChain_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetAccount(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetAccounts(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetStorage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetStorage(ctx, req.(*StorageAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetStorageAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetStorageAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetStorageAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetStorageAt(ctx, req.(*StorageAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetValidator(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetValidators(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_Getstatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).Getstatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/Getstatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).Getstatus(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetBlock(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetBlocks(ctx, req.(*BlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetGenesis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetGenesis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetGenesis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetGenesis(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetChainID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetChainID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetChainID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetChainID(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetLatestBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetLatestBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetLatestBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetLatestBlock(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetConsensusState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetConsensusState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetConsensusState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetConsensusState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetBlockTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetBlockTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetBlockTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetBlockTxs(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BlockChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto3.BlockChain",
	HandlerType: (*BlockChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccount",
			Handler:    _BlockChain_GetAccount_Handler,
		},
		{
			MethodName: "GetAccounts",
			Handler:    _BlockChain_GetAccounts_Handler,
		},
		{
			MethodName: "GetStorage",
			Handler:    _BlockChain_GetStorage_Handler,
		},
		{
			MethodName: "GetStorageAt",
			Handler:    _BlockChain_GetStorageAt_Handler,
		},
		{
			MethodName: "GetValidator",
			Handler:    _BlockChain_GetValidator_Handler,
		},
		{
			MethodName: "GetValidators",
			Handler:    _BlockChain_GetValidators_Handler,
		},
		{
			MethodName: "Getstatus",
			Handler:    _BlockChain_Getstatus_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BlockChain_GetBlock_Handler,
		},
		{
			MethodName: "GetBlocks",
			Handler:    _BlockChain_GetBlocks_Handler,
		},
		{
			MethodName: "GetGenesis",
			Handler:    _BlockChain_GetGenesis_Handler,
		},
		{
			MethodName: "GetChainID",
			Handler:    _BlockChain_GetChainID_Handler,
		},
		{
			MethodName: "GetLatestBlock",
			Handler:    _BlockChain_GetLatestBlock_Handler,
		},
		{
			MethodName: "GetConsensusState",
			Handler:    _BlockChain_GetConsensusState_Handler,
		},
		{
			MethodName: "GetBlockTxs",
			Handler:    _BlockChain_GetBlockTxs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/grpc/proto3/blockchain.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.BlockHeight))
	}
	if len(m.Accounts) > 0 {
		for _, msg := range m.Accounts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Account.Size()))
		n1, err := m.Account.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Validator != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Validator.Size()))
		n2, err := m.Validator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.BlockHeight))
	}
	if len(m.Validators) > 0 {
		for _, msg := range m.Validators {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListAccountsParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAccountsParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Address.Size()))
	n3, err := m.Address.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageAtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageAtRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Address.Size()))
	n4, err := m.Address.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Key.Size()))
	n5, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Key.Size()))
	n6, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Value.Size()))
	n7, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.RoundState.Size()))
	n8, err := m.RoundState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.PeerRoundStates) > 0 {
		for _, msg := range m.PeerRoundStates {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChainName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.ChainName)))
		i += copy(dAtA[i:], m.ChainName)
	}
	if len(m.ChainId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.ChainId)))
		i += copy(dAtA[i:], m.ChainId)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.GenesisHash.Size()))
	n9, err := m.GenesisHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.NodeInfo.Size()))
	n10, err := m.NodeInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.GenesisHash.Size()))
	n11, err := m.GenesisHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.PubKey.Size()))
	n12, err := m.PubKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x22
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.LatestBlockHash.Size()))
	n13, err := m.LatestBlockHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if m.LatestBlockHeight != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.LatestBlockHeight))
	}
	if m.LatestBlockTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.LatestBlockTime))
	}
	if len(m.NodeVersion) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.NodeVersion)))
		i += copy(dAtA[i:], m.NodeVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlocksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.MinHeight))
	}
	if m.MaxHeight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.MaxHeight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.BlockMeta.Size()))
		n14, err := m.BlockMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Block != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Block.Size()))
		n15, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlocksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.LastHeight))
	}
	if len(m.BlockMeta) > 0 {
		for _, msg := range m.BlockMeta {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.BlockMeta.Size()))
		n16, err := m.BlockMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Block != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Block.Size()))
		n17, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenesisResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Genesis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Genesis.Size()))
		n18, err := m.Genesis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockTxsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockTxsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Count))
	}
	if len(m.Txs) > 0 {
		for _, msg := range m.Txs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintBlockchain(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.BlockHeight))
	}
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Validator != nil {
		l = m.Validator.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.BlockHeight))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAccountsParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Address.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageAtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Address.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.Key.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RoundState.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if len(m.PeerRoundStates) > 0 {
		for _, e := range m.PeerRoundStates {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainName)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	l = m.GenesisHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NodeInfo.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.GenesisHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.PubKey.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.LatestBlockHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.LatestBlockHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.LatestBlockHeight))
	}
	if m.LatestBlockTime != 0 {
		n += 1 + sovBlockchain(uint64(m.LatestBlockTime))
	}
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovBlockchain(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.MinHeight))
	}
	if m.MaxHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.MaxHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockMeta != nil {
		l = m.BlockMeta.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.LastHeight))
	}
	if len(m.BlockMeta) > 0 {
		for _, e := range m.BlockMeta {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockMeta != nil {
		l = m.BlockMeta.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenesisResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Genesis != nil {
		l = m.Genesis.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockTxsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovBlockchain(uint64(m.Count))
	}
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBlockchain(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBlockchain(x uint64) (n int) {
	return sovBlockchain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, &AccountResponse{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &github_com_gallactic_gallactic_core_account.Account{}
			}
			if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validator == nil {
				m.Validator = &github_com_gallactic_gallactic_core_validator.Validator{}
			}
			if err := m.Validator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &ValidatorResponse{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccountsParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccountsParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccountsParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageAtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageAtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageAtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RoundState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRoundStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerRoundStates = append(m.PeerRoundStates, github_com_tendermint_tendermint_consensus_types.PeerRoundState{})
			if err := m.PeerRoundStates[len(m.PeerRoundStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GenesisHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GenesisHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PubKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatestBlockHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockHeight", wireType)
			}
			m.LatestBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBlockHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockTime", wireType)
			}
			m.LatestBlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBlockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHeight", wireType)
			}
			m.MinHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHeight", wireType)
			}
			m.MaxHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_tendermint_tendermint_types.BlockMeta
			m.BlockMeta = &v
			if err := m.BlockMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_tendermint_tendermint_types.Block
			m.Block = &v
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_tendermint_tendermint_types.BlockMeta
			m.BlockMeta = append(m.BlockMeta, v)
			if err := m.BlockMeta[len(m.BlockMeta)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_tendermint_tendermint_types.BlockMeta
			m.BlockMeta = &v
			if err := m.BlockMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_tendermint_tendermint_types.Block
			m.Block = &v
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Genesis == nil {
				m.Genesis = &github_com_gallactic_gallactic_core_proposal.Genesis{}
			}
			if err := m.Genesis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockTxsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockTxsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockTxsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, github_com_gallactic_gallactic_txs.Envelope{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBlockchain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBlockchain
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBlockchain
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBlockchain(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBlockchain = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBlockchain   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("rpc/grpc/proto3/blockchain.proto", fileDescriptor_blockchain_742c198a80beb388)
}

var fileDescriptor_blockchain_742c198a80beb388 = []byte{
	// 1180 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xc6, 0x75, 0x1c, 0xbf, 0x7c, 0x8f, 0x42, 0x30, 0x56, 0x64, 0x47, 0x7b, 0x40, 0x41,
	0xb4, 0x76, 0x95, 0xa4, 0x84, 0xaf, 0xa8, 0xb2, 0xd3, 0xe2, 0x44, 0x09, 0x4d, 0xd8, 0x54, 0x11,
	0x17, 0x54, 0xad, 0xd7, 0x13, 0x67, 0xe9, 0x7a, 0x67, 0xbb, 0x33, 0x5b, 0xc5, 0x07, 0x38, 0x21,
	0x21, 0x0e, 0x70, 0xe6, 0xc8, 0x11, 0x89, 0x2b, 0x12, 0x57, 0x8e, 0x39, 0x72, 0xe2, 0xe0, 0x83,
	0x85, 0x92, 0x3f, 0x04, 0xb4, 0xb3, 0x33, 0xb3, 0xeb, 0x8d, 0x2c, 0x37, 0xd4, 0xbd, 0x58, 0x3b,
	0x6f, 0xde, 0xfb, 0xbd, 0xdf, 0x7b, 0xf3, 0xe6, 0xcd, 0x33, 0xac, 0xf9, 0x9e, 0x55, 0x6d, 0x87,
	0x3f, 0x9e, 0x4f, 0x18, 0xd9, 0xac, 0x36, 0x1d, 0x62, 0x3d, 0xb7, 0xce, 0x4d, 0xdb, 0xad, 0x70,
	0x09, 0x9a, 0x8a, 0x36, 0x8a, 0xf7, 0xda, 0x36, 0x3b, 0x0f, 0x9a, 0x15, 0x8b, 0x74, 0xaa, 0x6d,
	0xd2, 0x26, 0x91, 0x41, 0x33, 0x38, 0xe3, 0x2b, 0xbe, 0xe0, 0x5f, 0x91, 0x59, 0x71, 0xb5, 0x4d,
	0x48, 0xdb, 0xc1, 0xb1, 0x16, 0x65, 0x7e, 0x60, 0xb1, 0x68, 0x57, 0xcf, 0x41, 0xf6, 0x71, 0xc7,
	0x63, 0x5d, 0xdd, 0x86, 0xc5, 0x9a, 0x65, 0x91, 0xc0, 0x65, 0xd4, 0xc0, 0xd4, 0x23, 0x2e, 0xc5,
	0x68, 0x0d, 0x66, 0xea, 0x21, 0x8b, 0x3d, 0x6c, 0xb7, 0xcf, 0x59, 0x41, 0x5b, 0xd3, 0xd6, 0xef,
	0x18, 0x49, 0x11, 0xda, 0x84, 0x69, 0x69, 0x55, 0x98, 0x5c, 0xcb, 0xac, 0xcf, 0x6c, 0xbc, 0x1d,
	0x01, 0x6f, 0x56, 0x84, 0x5c, 0x82, 0x19, 0x4a, 0x51, 0xff, 0x06, 0x16, 0x52, 0x9b, 0xe8, 0x6b,
	0xc8, 0x09, 0x11, 0xf7, 0x32, 0x1c, 0xa6, 0xbe, 0xdd, 0xeb, 0x97, 0x37, 0x93, 0x19, 0x30, 0x1d,
	0xc7, 0xb4, 0x98, 0x6d, 0x25, 0xbe, 0x2c, 0xe2, 0xe3, 0xaa, 0x19, 0x19, 0x2a, 0x00, 0xe9, 0x40,
	0xff, 0x41, 0x83, 0xa5, 0x53, 0xd3, 0xb1, 0x5b, 0x26, 0x23, 0xbe, 0x62, 0xc0, 0x20, 0xaf, 0x84,
	0x82, 0xc3, 0x3b, 0x92, 0xc3, 0x0d, 0xed, 0xfa, 0x27, 0xbd, 0x7e, 0x79, 0xfb, 0x55, 0x58, 0xbc,
	0x94, 0xa6, 0x09, 0x90, 0xd8, 0x91, 0xfe, 0x02, 0x90, 0x5a, 0xdc, 0x26, 0xef, 0x1f, 0x01, 0xc4,
	0x76, 0x22, 0xf3, 0xc3, 0xe9, 0x1a, 0x09, 0x65, 0xfd, 0x3d, 0x58, 0x3a, 0xb4, 0x29, 0x93, 0xa7,
	0x71, 0x6c, 0xfa, 0x66, 0x07, 0x2d, 0x43, 0xf6, 0x8b, 0x00, 0xfb, 0x5d, 0xee, 0x2b, 0x6f, 0x44,
	0x0b, 0xdd, 0x84, 0xf9, 0x5a, 0xab, 0xe5, 0x63, 0x4a, 0x0d, 0xfc, 0x22, 0xc0, 0x94, 0xa1, 0x23,
	0xc8, 0x09, 0x09, 0xd7, 0x9c, 0xad, 0x3f, 0xb8, 0xec, 0x97, 0x27, 0x7a, 0xfd, 0xf2, 0xbd, 0x51,
	0xc9, 0xf0, 0xbb, 0x1e, 0x23, 0x15, 0x09, 0x27, 0x51, 0xf4, 0xdf, 0x35, 0x58, 0x3c, 0x61, 0xc4,
	0x37, 0xdb, 0xb8, 0xc6, 0xde, 0x94, 0x17, 0x74, 0x04, 0x99, 0x03, 0xdc, 0x2d, 0x4c, 0x72, 0xb0,
	0x1d, 0x01, 0xf6, 0x60, 0xe4, 0xf9, 0x75, 0x3a, 0xc4, 0xad, 0x36, 0x6d, 0xd7, 0xf4, 0xbb, 0x95,
	0x3d, 0x7c, 0x51, 0xef, 0x32, 0x4c, 0x8d, 0x10, 0x49, 0xff, 0x43, 0x83, 0x05, 0x41, 0x5b, 0x9d,
	0x9a, 0x70, 0xa2, 0x8d, 0xcb, 0x09, 0x3a, 0x81, 0xec, 0xa9, 0xe9, 0x04, 0x78, 0x3c, 0xbc, 0x23,
	0x2c, 0xfd, 0xa7, 0x49, 0x58, 0xda, 0x0d, 0xf9, 0xba, 0x34, 0x88, 0x2b, 0xce, 0x06, 0x30, 0x48,
	0xe0, 0xb6, 0x4e, 0x98, 0xc9, 0xb0, 0x08, 0x61, 0x5f, 0xf8, 0xab, 0x25, 0xfc, 0x31, 0xec, 0xb6,
	0xb0, 0xdf, 0xb1, 0x5d, 0x96, 0xfc, 0xb4, 0x24, 0x5e, 0x95, 0x75, 0x3d, 0x4c, 0x2b, 0x31, 0xd4,
	0x89, 0xdd, 0xf1, 0x1c, 0x6c, 0x24, 0xc0, 0xd1, 0x8f, 0x1a, 0x2c, 0x1c, 0x63, 0xec, 0xc7, 0x22,
	0x59, 0xc0, 0xc5, 0x4a, 0xd4, 0xaa, 0x2a, 0xb2, 0x55, 0x55, 0xc2, 0x42, 0xe5, 0xb4, 0xeb, 0x0d,
	0x41, 0xe6, 0xe1, 0xad, 0xc9, 0x0c, 0xfa, 0x32, 0xd2, 0xbe, 0xf5, 0x5f, 0x35, 0x98, 0xdb, 0x0d,
	0xdb, 0xac, 0x4a, 0xc6, 0x2a, 0xe4, 0xb9, 0xe0, 0x89, 0xd9, 0xc1, 0xe2, 0x42, 0xc4, 0x02, 0x54,
	0x80, 0x1c, 0x5f, 0xec, 0xb7, 0xf8, 0xb9, 0xe4, 0x0d, 0xb9, 0x44, 0xcf, 0x60, 0xa6, 0x81, 0x5d,
	0x4c, 0x6d, 0xba, 0x67, 0xd2, 0xf3, 0x42, 0x66, 0x1c, 0xa7, 0x96, 0x44, 0xd4, 0xff, 0xcd, 0xc0,
	0x7c, 0xc8, 0x3a, 0x71, 0x70, 0x5f, 0xc2, 0xf4, 0x13, 0xd2, 0xc2, 0xfb, 0xee, 0x19, 0x11, 0xc7,
	0xf6, 0xa9, 0x70, 0xb8, 0x35, 0x32, 0x53, 0xde, 0x86, 0x57, 0x79, 0x84, 0xcf, 0xcc, 0xc0, 0x61,
	0x12, 0xc3, 0x50, 0x68, 0xe9, 0x68, 0x26, 0xc7, 0x1d, 0x0d, 0x3a, 0x82, 0xa9, 0xe3, 0xa0, 0x19,
	0x5e, 0x99, 0x28, 0x53, 0xdb, 0x02, 0xbb, 0xfa, 0x6a, 0x97, 0xfc, 0x38, 0x68, 0x3a, 0xb6, 0x75,
	0x80, 0xbb, 0x86, 0x80, 0x41, 0x6d, 0x58, 0x38, 0x0c, 0x8f, 0x94, 0x45, 0x9d, 0x32, 0x64, 0x7d,
	0x67, 0x1c, 0xac, 0xd3, 0xa8, 0xe8, 0x2e, 0x2c, 0x25, 0x45, 0x51, 0x97, 0xce, 0xf2, 0x2e, 0x7d,
	0x73, 0x03, 0xad, 0x0f, 0xd0, 0x7a, 0x6a, 0x77, 0x70, 0x61, 0x6a, 0x4d, 0x5b, 0xcf, 0x18, 0x69,
	0x71, 0xd8, 0xf7, 0xc3, 0xf4, 0x9f, 0x62, 0x9f, 0xda, 0xc4, 0x2d, 0xe4, 0x78, 0x79, 0x25, 0x45,
	0xfa, 0xbb, 0x30, 0xcb, 0xd5, 0x65, 0xa7, 0x5c, 0x81, 0xa9, 0xf3, 0xe4, 0x23, 0x21, 0x56, 0xfa,
	0x01, 0xcc, 0x71, 0x3d, 0xd5, 0xb8, 0x57, 0x21, 0xdf, 0xb1, 0xdd, 0x81, 0x07, 0x25, 0x16, 0xf0,
	0x5d, 0xf3, 0x42, 0xec, 0x4e, 0x8a, 0x5d, 0x29, 0xd0, 0x7f, 0xd3, 0x04, 0x9a, 0xaa, 0x3a, 0x03,
	0xf2, 0x5c, 0xf0, 0x39, 0x66, 0xa6, 0x28, 0xbb, 0xad, 0x5e, 0xbf, 0x7c, 0x7f, 0x64, 0xc9, 0x45,
	0x57, 0x52, 0xd9, 0x1a, 0x31, 0x0c, 0xfa, 0x0c, 0xb2, 0x7c, 0x21, 0x2a, 0xed, 0x7e, 0xaf, 0x5f,
	0xbe, 0x7b, 0x1b, 0x3c, 0x23, 0x32, 0xd7, 0xbf, 0xd3, 0x60, 0x5e, 0xc6, 0x2e, 0xe8, 0x96, 0x00,
	0x0e, 0x4d, 0xca, 0x06, 0xa2, 0x4f, 0x48, 0x06, 0xc3, 0x09, 0x7b, 0xd1, 0xeb, 0x87, 0xa3, 0x3f,
	0x4b, 0x60, 0xbe, 0x89, 0x7c, 0xe9, 0x47, 0x22, 0x5f, 0x63, 0x4b, 0xdc, 0xb7, 0xb0, 0x20, 0xae,
	0xa7, 0x4a, 0xdc, 0x73, 0xc8, 0x09, 0x51, 0x7a, 0x2c, 0x4b, 0x69, 0xd6, 0x3f, 0x4c, 0x75, 0x9c,
	0xa1, 0x03, 0x91, 0xe7, 0x13, 0x8f, 0x50, 0xd3, 0x51, 0x08, 0xd2, 0x83, 0xfe, 0xbd, 0x06, 0x8b,
	0xd1, 0x5d, 0xb8, 0x88, 0x19, 0x2c, 0x43, 0x76, 0x57, 0x8d, 0x85, 0x59, 0x23, 0x5a, 0xa0, 0xaf,
	0x20, 0xf3, 0xf4, 0x82, 0x16, 0x32, 0x23, 0x9f, 0x8d, 0x6a, 0xaf, 0x5f, 0x7e, 0x7f, 0x04, 0x2d,
	0x76, 0x41, 0x2b, 0x8f, 0xdd, 0x97, 0xd8, 0x21, 0x1e, 0x36, 0x42, 0xdc, 0x8d, 0xbf, 0xa7, 0x00,
	0x38, 0x13, 0xde, 0xd9, 0xd1, 0x0e, 0x40, 0x03, 0xcb, 0x81, 0x09, 0xad, 0xa8, 0xc9, 0x74, 0x60,
	0x34, 0x2a, 0x0e, 0x9b, 0x58, 0xd1, 0x07, 0x61, 0x23, 0x55, 0xf3, 0x16, 0x9a, 0x93, 0x7a, 0x7c,
	0xee, 0x2e, 0x16, 0x52, 0x66, 0x71, 0xe8, 0x0f, 0xb9, 0x5b, 0x31, 0x65, 0x20, 0xa5, 0x97, 0x9e,
	0x96, 0x62, 0xc7, 0xe9, 0x81, 0xa4, 0x06, 0xb3, 0x31, 0x40, 0x8d, 0xfd, 0x7f, 0x08, 0x35, 0x3d,
	0x0e, 0x0d, 0x7e, 0xf8, 0xec, 0x89, 0x3e, 0x86, 0xb9, 0x24, 0xc4, 0x8d, 0x04, 0x14, 0x6f, 0x98,
	0xc6, 0x29, 0xd8, 0x80, 0x7c, 0x03, 0x33, 0xca, 0x9f, 0xbc, 0xb4, 0xdd, 0x4a, 0xcc, 0x79, 0xe0,
	0x45, 0xdc, 0x86, 0xe9, 0x06, 0x8e, 0x9a, 0x2a, 0x5a, 0x96, 0x3a, 0xc9, 0xa6, 0x59, 0x7c, 0x2b,
	0x25, 0x55, 0x44, 0xf3, 0xd2, 0x90, 0xa2, 0x41, 0x1d, 0x15, 0xe7, 0x4a, 0x5a, 0x2c, 0x6c, 0xb7,
	0xf8, 0x59, 0x89, 0x4a, 0x4e, 0x33, 0x1d, 0x76, 0x69, 0xd0, 0x06, 0xb7, 0x8a, 0xc6, 0x87, 0x47,
	0x69, 0x2b, 0xc5, 0x60, 0x70, 0x38, 0xd9, 0x81, 0xf9, 0x06, 0x66, 0x89, 0x97, 0xe3, 0x76, 0x41,
	0xee, 0xc0, 0x52, 0xe8, 0x52, 0xce, 0x48, 0xd1, 0x48, 0x96, 0xf2, 0xac, 0x0e, 0xf3, 0xe6, 0x9c,
	0xb8, 0xc3, 0x6b, 0x59, 0xde, 0xd2, 0x21, 0xae, 0x0b, 0x03, 0xd2, 0xc4, 0x6d, 0xae, 0xaf, 0x5e,
	0x5e, 0x95, 0xb4, 0xbf, 0xae, 0x4a, 0xda, 0x3f, 0x57, 0x25, 0xed, 0xe7, 0xeb, 0xd2, 0xc4, 0x2f,
	0xd7, 0xa5, 0x89, 0x3f, 0xaf, 0x4b, 0xda, 0xe5, 0x75, 0x49, 0x6b, 0x8a, 0x3f, 0xb8, 0xff, 0x05,
	0x00, 0x00, 0xff, 0xff, 0x95, 0x85, 0x3d, 0xa1, 0x0b, 0x0f, 0x00, 0x00,
}
