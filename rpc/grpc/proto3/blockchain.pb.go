// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpc/grpc/proto3/blockchain.proto

package proto3

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import github_com_gallactic_gallactic_core_account "github.com/gallactic/gallactic/core/account"
import github_com_gallactic_gallactic_common_binary "github.com/gallactic/gallactic/common/binary"
import github_com_tendermint_tendermint_consensus_types "github.com/tendermint/tendermint/consensus/types"
import github_com_gallactic_gallactic_core_consensus_tendermint_p2p "github.com/gallactic/gallactic/core/consensus/tendermint/p2p"
import github_com_gallactic_gallactic_crypto "github.com/gallactic/gallactic/crypto"
import github_com_gallactic_gallactic_core_proposal "github.com/gallactic/gallactic/core/proposal"
import time "time"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func (*Empty) XXX_MessageName() string {
	return "proto3.Empty"
}

type AddressRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressRequest) Reset()         { *m = AddressRequest{} }
func (m *AddressRequest) String() string { return proto.CompactTextString(m) }
func (*AddressRequest) ProtoMessage()    {}
func (*AddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{1}
}
func (m *AddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressRequest.Merge(dst, src)
}
func (m *AddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddressRequest proto.InternalMessageInfo

func (m *AddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (*AddressRequest) XXX_MessageName() string {
	return "proto3.AddressRequest"
}

type AccountResponse struct {
	Account              *github_com_gallactic_gallactic_core_account.Account `protobuf:"bytes,1,opt,name=Account,customtype=github.com/gallactic/gallactic/core/account.Account" json:"Account,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                             `json:"-"`
	XXX_unrecognized     []byte                                               `json:"-"`
	XXX_sizecache        int32                                                `json:"-"`
}

func (m *AccountResponse) Reset()         { *m = AccountResponse{} }
func (m *AccountResponse) String() string { return proto.CompactTextString(m) }
func (*AccountResponse) ProtoMessage()    {}
func (*AccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{2}
}
func (m *AccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountResponse.Merge(dst, src)
}
func (m *AccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *AccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AccountResponse proto.InternalMessageInfo

func (*AccountResponse) XXX_MessageName() string {
	return "proto3.AccountResponse"
}

type AccountsResponse struct {
	BlockHeight          uint64             `protobuf:"varint,1,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	Accounts             []*AccountResponse `protobuf:"bytes,2,rep,name=Accounts" json:"Accounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AccountsResponse) Reset()         { *m = AccountsResponse{} }
func (m *AccountsResponse) String() string { return proto.CompactTextString(m) }
func (*AccountsResponse) ProtoMessage()    {}
func (*AccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{3}
}
func (m *AccountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AccountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountsResponse.Merge(dst, src)
}
func (m *AccountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *AccountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AccountsResponse proto.InternalMessageInfo

func (m *AccountsResponse) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *AccountsResponse) GetAccounts() []*AccountResponse {
	if m != nil {
		return m.Accounts
	}
	return nil
}

func (*AccountsResponse) XXX_MessageName() string {
	return "proto3.AccountsResponse"
}

type ValidatorResponse struct {
	Validator            *ValidatorInfo `protobuf:"bytes,1,opt,name=Validator" json:"Validator,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ValidatorResponse) Reset()         { *m = ValidatorResponse{} }
func (m *ValidatorResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorResponse) ProtoMessage()    {}
func (*ValidatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{4}
}
func (m *ValidatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ValidatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorResponse.Merge(dst, src)
}
func (m *ValidatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorResponse proto.InternalMessageInfo

func (m *ValidatorResponse) GetValidator() *ValidatorInfo {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (*ValidatorResponse) XXX_MessageName() string {
	return "proto3.ValidatorResponse"
}

type ValidatorsResponse struct {
	BlockHeight          uint64           `protobuf:"varint,1,opt,name=BlockHeight,proto3" json:"BlockHeight,omitempty"`
	Validators           []*ValidatorInfo `protobuf:"bytes,2,rep,name=Validators" json:"Validators,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ValidatorsResponse) Reset()         { *m = ValidatorsResponse{} }
func (m *ValidatorsResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorsResponse) ProtoMessage()    {}
func (*ValidatorsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{5}
}
func (m *ValidatorsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ValidatorsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorsResponse.Merge(dst, src)
}
func (m *ValidatorsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorsResponse proto.InternalMessageInfo

func (m *ValidatorsResponse) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ValidatorsResponse) GetValidators() []*ValidatorInfo {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (*ValidatorsResponse) XXX_MessageName() string {
	return "proto3.ValidatorsResponse"
}

type ListAccountsParam struct {
	Query                string   `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAccountsParam) Reset()         { *m = ListAccountsParam{} }
func (m *ListAccountsParam) String() string { return proto.CompactTextString(m) }
func (*ListAccountsParam) ProtoMessage()    {}
func (*ListAccountsParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{6}
}
func (m *ListAccountsParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAccountsParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAccountsParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListAccountsParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAccountsParam.Merge(dst, src)
}
func (m *ListAccountsParam) XXX_Size() int {
	return m.Size()
}
func (m *ListAccountsParam) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAccountsParam.DiscardUnknown(m)
}

var xxx_messageInfo_ListAccountsParam proto.InternalMessageInfo

func (m *ListAccountsParam) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (*ListAccountsParam) XXX_MessageName() string {
	return "proto3.ListAccountsParam"
}

type StorageRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageRequest) Reset()         { *m = StorageRequest{} }
func (m *StorageRequest) String() string { return proto.CompactTextString(m) }
func (*StorageRequest) ProtoMessage()    {}
func (*StorageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{7}
}
func (m *StorageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StorageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageRequest.Merge(dst, src)
}
func (m *StorageRequest) XXX_Size() int {
	return m.Size()
}
func (m *StorageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StorageRequest proto.InternalMessageInfo

func (m *StorageRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (*StorageRequest) XXX_MessageName() string {
	return "proto3.StorageRequest"
}

type StorageResponse struct {
	StorageItems         []StorageItem `protobuf:"bytes,1,rep,name=StorageItems" json:"StorageItems"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *StorageResponse) Reset()         { *m = StorageResponse{} }
func (m *StorageResponse) String() string { return proto.CompactTextString(m) }
func (*StorageResponse) ProtoMessage()    {}
func (*StorageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{8}
}
func (m *StorageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StorageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageResponse.Merge(dst, src)
}
func (m *StorageResponse) XXX_Size() int {
	return m.Size()
}
func (m *StorageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StorageResponse proto.InternalMessageInfo

func (m *StorageResponse) GetStorageItems() []StorageItem {
	if m != nil {
		return m.StorageItems
	}
	return nil
}

func (*StorageResponse) XXX_MessageName() string {
	return "proto3.StorageResponse"
}

type StorageItem struct {
	Key                  github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,1,opt,name=Key,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"Key"`
	Value                github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,2,opt,name=Value,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"Value"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *StorageItem) Reset()         { *m = StorageItem{} }
func (m *StorageItem) String() string { return proto.CompactTextString(m) }
func (*StorageItem) ProtoMessage()    {}
func (*StorageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{9}
}
func (m *StorageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StorageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageItem.Merge(dst, src)
}
func (m *StorageItem) XXX_Size() int {
	return m.Size()
}
func (m *StorageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageItem.DiscardUnknown(m)
}

var xxx_messageInfo_StorageItem proto.InternalMessageInfo

func (*StorageItem) XXX_MessageName() string {
	return "proto3.StorageItem"
}

type StorageAtRequest struct {
	Address              string                                                `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Key                  github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,2,opt,name=Key,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"Key"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *StorageAtRequest) Reset()         { *m = StorageAtRequest{} }
func (m *StorageAtRequest) String() string { return proto.CompactTextString(m) }
func (*StorageAtRequest) ProtoMessage()    {}
func (*StorageAtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{10}
}
func (m *StorageAtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageAtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageAtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StorageAtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageAtRequest.Merge(dst, src)
}
func (m *StorageAtRequest) XXX_Size() int {
	return m.Size()
}
func (m *StorageAtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageAtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StorageAtRequest proto.InternalMessageInfo

func (m *StorageAtRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (*StorageAtRequest) XXX_MessageName() string {
	return "proto3.StorageAtRequest"
}

type StorageAtResponse struct {
	Key                  github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,1,opt,name=Key,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"Key"`
	Value                github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,2,opt,name=Value,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"Value"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *StorageAtResponse) Reset()         { *m = StorageAtResponse{} }
func (m *StorageAtResponse) String() string { return proto.CompactTextString(m) }
func (*StorageAtResponse) ProtoMessage()    {}
func (*StorageAtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{11}
}
func (m *StorageAtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageAtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageAtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StorageAtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageAtResponse.Merge(dst, src)
}
func (m *StorageAtResponse) XXX_Size() int {
	return m.Size()
}
func (m *StorageAtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageAtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StorageAtResponse proto.InternalMessageInfo

func (*StorageAtResponse) XXX_MessageName() string {
	return "proto3.StorageAtResponse"
}

type ConsensusResponse struct {
	RoundState           github_com_tendermint_tendermint_consensus_types.RoundStateSimple `protobuf:"bytes,1,opt,name=RoundState,proto3,customtype=github.com/tendermint/tendermint/consensus/types.RoundStateSimple" json:"RoundState"`
	PeerRoundStates      []github_com_tendermint_tendermint_consensus_types.PeerRoundState `protobuf:"bytes,2,rep,name=PeerRoundStates,customtype=github.com/tendermint/tendermint/consensus/types.PeerRoundState" json:"PeerRoundStates"`
	XXX_NoUnkeyedLiteral struct{}                                                          `json:"-"`
	XXX_unrecognized     []byte                                                            `json:"-"`
	XXX_sizecache        int32                                                             `json:"-"`
}

func (m *ConsensusResponse) Reset()         { *m = ConsensusResponse{} }
func (m *ConsensusResponse) String() string { return proto.CompactTextString(m) }
func (*ConsensusResponse) ProtoMessage()    {}
func (*ConsensusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{12}
}
func (m *ConsensusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusResponse.Merge(dst, src)
}
func (m *ConsensusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusResponse proto.InternalMessageInfo

func (*ConsensusResponse) XXX_MessageName() string {
	return "proto3.ConsensusResponse"
}

type ChainResponse struct {
	ChainName            string                                                `protobuf:"bytes,1,opt,name=ChainName,proto3" json:"ChainName,omitempty"`
	ChainId              string                                                `protobuf:"bytes,2,opt,name=ChainId,proto3" json:"ChainId,omitempty"`
	GenesisHash          github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,3,opt,name=GenesisHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"GenesisHash"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *ChainResponse) Reset()         { *m = ChainResponse{} }
func (m *ChainResponse) String() string { return proto.CompactTextString(m) }
func (*ChainResponse) ProtoMessage()    {}
func (*ChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{13}
}
func (m *ChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainResponse.Merge(dst, src)
}
func (m *ChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChainResponse proto.InternalMessageInfo

func (m *ChainResponse) GetChainName() string {
	if m != nil {
		return m.ChainName
	}
	return ""
}

func (m *ChainResponse) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (*ChainResponse) XXX_MessageName() string {
	return "proto3.ChainResponse"
}

type StatusResponse struct {
	NodeInfo             github_com_gallactic_gallactic_core_consensus_tendermint_p2p.GNodeInfo `protobuf:"bytes,1,opt,name=NodeInfo,proto3,customtype=github.com/gallactic/gallactic/core/consensus/tendermint/p2p.GNodeInfo" json:"NodeInfo"`
	GenesisHash          github_com_gallactic_gallactic_common_binary.HexBytes                  `protobuf:"bytes,2,opt,name=GenesisHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"GenesisHash"`
	PubKey               github_com_gallactic_gallactic_crypto.PublicKey                        `protobuf:"bytes,3,opt,name=PubKey,proto3,customtype=github.com/gallactic/gallactic/crypto.PublicKey" json:"PubKey"`
	LatestBlockHash      github_com_gallactic_gallactic_common_binary.HexBytes                  `protobuf:"bytes,4,opt,name=LatestBlockHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"LatestBlockHash"`
	LatestBlockHeight    uint64                                                                 `protobuf:"varint,5,opt,name=LatestBlockHeight,proto3" json:"LatestBlockHeight,omitempty"`
	LatestBlockTime      int64                                                                  `protobuf:"varint,6,opt,name=LatestBlockTime,proto3" json:"LatestBlockTime,omitempty"`
	NodeVersion          string                                                                 `protobuf:"bytes,7,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *StatusResponse) Reset()         { *m = StatusResponse{} }
func (m *StatusResponse) String() string { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()    {}
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{14}
}
func (m *StatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusResponse.Merge(dst, src)
}
func (m *StatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatusResponse proto.InternalMessageInfo

func (m *StatusResponse) GetLatestBlockHeight() uint64 {
	if m != nil {
		return m.LatestBlockHeight
	}
	return 0
}

func (m *StatusResponse) GetLatestBlockTime() int64 {
	if m != nil {
		return m.LatestBlockTime
	}
	return 0
}

func (m *StatusResponse) GetNodeVersion() string {
	if m != nil {
		return m.NodeVersion
	}
	return ""
}

func (*StatusResponse) XXX_MessageName() string {
	return "proto3.StatusResponse"
}

type BlockRequest struct {
	Height               uint64   `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockRequest) Reset()         { *m = BlockRequest{} }
func (m *BlockRequest) String() string { return proto.CompactTextString(m) }
func (*BlockRequest) ProtoMessage()    {}
func (*BlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{15}
}
func (m *BlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRequest.Merge(dst, src)
}
func (m *BlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRequest proto.InternalMessageInfo

func (m *BlockRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (*BlockRequest) XXX_MessageName() string {
	return "proto3.BlockRequest"
}

type BlocksRequest struct {
	MinHeight            uint64   `protobuf:"varint,1,opt,name=minHeight,proto3" json:"minHeight,omitempty"`
	MaxHeight            uint64   `protobuf:"varint,2,opt,name=maxHeight,proto3" json:"maxHeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlocksRequest) Reset()         { *m = BlocksRequest{} }
func (m *BlocksRequest) String() string { return proto.CompactTextString(m) }
func (*BlocksRequest) ProtoMessage()    {}
func (*BlocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{16}
}
func (m *BlocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlocksRequest.Merge(dst, src)
}
func (m *BlocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlocksRequest proto.InternalMessageInfo

func (m *BlocksRequest) GetMinHeight() uint64 {
	if m != nil {
		return m.MinHeight
	}
	return 0
}

func (m *BlocksRequest) GetMaxHeight() uint64 {
	if m != nil {
		return m.MaxHeight
	}
	return 0
}

func (*BlocksRequest) XXX_MessageName() string {
	return "proto3.BlocksRequest"
}

type BlockResponse struct {
	Block                *BlockInfo `protobuf:"bytes,1,opt,name=Block" json:"Block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BlockResponse) Reset()         { *m = BlockResponse{} }
func (m *BlockResponse) String() string { return proto.CompactTextString(m) }
func (*BlockResponse) ProtoMessage()    {}
func (*BlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{17}
}
func (m *BlockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockResponse.Merge(dst, src)
}
func (m *BlockResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockResponse proto.InternalMessageInfo

func (m *BlockResponse) GetBlock() *BlockInfo {
	if m != nil {
		return m.Block
	}
	return nil
}

func (*BlockResponse) XXX_MessageName() string {
	return "proto3.BlockResponse"
}

type BlocksResponse struct {
	Blocks               []BlockInfo `protobuf:"bytes,1,rep,name=Blocks" json:"Blocks"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BlocksResponse) Reset()         { *m = BlocksResponse{} }
func (m *BlocksResponse) String() string { return proto.CompactTextString(m) }
func (*BlocksResponse) ProtoMessage()    {}
func (*BlocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{18}
}
func (m *BlocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlocksResponse.Merge(dst, src)
}
func (m *BlocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlocksResponse proto.InternalMessageInfo

func (m *BlocksResponse) GetBlocks() []BlockInfo {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (*BlocksResponse) XXX_MessageName() string {
	return "proto3.BlocksResponse"
}

type GenesisResponse struct {
	Genesis              *github_com_gallactic_gallactic_core_proposal.Genesis `protobuf:"bytes,1,opt,name=Genesis,customtype=github.com/gallactic/gallactic/core/proposal.Genesis" json:"Genesis,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *GenesisResponse) Reset()         { *m = GenesisResponse{} }
func (m *GenesisResponse) String() string { return proto.CompactTextString(m) }
func (*GenesisResponse) ProtoMessage()    {}
func (*GenesisResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{19}
}
func (m *GenesisResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenesisResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisResponse.Merge(dst, src)
}
func (m *GenesisResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenesisResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisResponse proto.InternalMessageInfo

func (*GenesisResponse) XXX_MessageName() string {
	return "proto3.GenesisResponse"
}

type BlockTxsResponse struct {
	Count                int32    `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
	Txs                  []TxInfo `protobuf:"bytes,2,rep,name=Txs" json:"Txs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockTxsResponse) Reset()         { *m = BlockTxsResponse{} }
func (m *BlockTxsResponse) String() string { return proto.CompactTextString(m) }
func (*BlockTxsResponse) ProtoMessage()    {}
func (*BlockTxsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{20}
}
func (m *BlockTxsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockTxsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockTxsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockTxsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockTxsResponse.Merge(dst, src)
}
func (m *BlockTxsResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockTxsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockTxsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockTxsResponse proto.InternalMessageInfo

func (m *BlockTxsResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *BlockTxsResponse) GetTxs() []TxInfo {
	if m != nil {
		return m.Txs
	}
	return nil
}

func (*BlockTxsResponse) XXX_MessageName() string {
	return "proto3.BlockTxsResponse"
}

type BlockchainInfoResponse struct {
	LastBlockHeight      uint64                                                `protobuf:"varint,1,opt,name=LastBlockHeight,proto3" json:"LastBlockHeight,omitempty"`
	LastBlockTime        time.Time                                             `protobuf:"bytes,2,opt,name=LastBlockTime,stdtime" json:"LastBlockTime"`
	LastBlockHash        github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,3,opt,name=LastBlockHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"LastBlockHash"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *BlockchainInfoResponse) Reset()         { *m = BlockchainInfoResponse{} }
func (m *BlockchainInfoResponse) String() string { return proto.CompactTextString(m) }
func (*BlockchainInfoResponse) ProtoMessage()    {}
func (*BlockchainInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{21}
}
func (m *BlockchainInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockchainInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockchainInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockchainInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockchainInfoResponse.Merge(dst, src)
}
func (m *BlockchainInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockchainInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockchainInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockchainInfoResponse proto.InternalMessageInfo

func (m *BlockchainInfoResponse) GetLastBlockHeight() uint64 {
	if m != nil {
		return m.LastBlockHeight
	}
	return 0
}

func (m *BlockchainInfoResponse) GetLastBlockTime() time.Time {
	if m != nil {
		return m.LastBlockTime
	}
	return time.Time{}
}

func (*BlockchainInfoResponse) XXX_MessageName() string {
	return "proto3.BlockchainInfoResponse"
}

type TxRequest struct {
	TxHash               string   `protobuf:"bytes,1,opt,name=TxHash,proto3" json:"TxHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRequest) Reset()         { *m = TxRequest{} }
func (m *TxRequest) String() string { return proto.CompactTextString(m) }
func (*TxRequest) ProtoMessage()    {}
func (*TxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{22}
}
func (m *TxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequest.Merge(dst, src)
}
func (m *TxRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequest proto.InternalMessageInfo

func (m *TxRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (*TxRequest) XXX_MessageName() string {
	return "proto3.TxRequest"
}

type TxResponse struct {
	Tx                   *TxInfo  `protobuf:"bytes,1,opt,name=Tx" json:"Tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxResponse) Reset()         { *m = TxResponse{} }
func (m *TxResponse) String() string { return proto.CompactTextString(m) }
func (*TxResponse) ProtoMessage()    {}
func (*TxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{23}
}
func (m *TxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxResponse.Merge(dst, src)
}
func (m *TxResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxResponse proto.InternalMessageInfo

func (m *TxResponse) GetTx() *TxInfo {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (*TxResponse) XXX_MessageName() string {
	return "proto3.TxResponse"
}

type BlockInfo struct {
	Header               HeaderInfo     `protobuf:"bytes,1,opt,name=header" json:"header"`
	LastCommitInfo       CommitInfo     `protobuf:"bytes,2,opt,name=last_commit_info,json=lastCommitInfo" json:"last_commit_info"`
	ByzantineValidators  []EvidenceInfo `protobuf:"bytes,3,rep,name=byzantine_validators,json=byzantineValidators" json:"byzantine_validators"`
	Txs                  []TxInfo       `protobuf:"bytes,4,rep,name=Txs" json:"Txs"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BlockInfo) Reset()         { *m = BlockInfo{} }
func (m *BlockInfo) String() string { return proto.CompactTextString(m) }
func (*BlockInfo) ProtoMessage()    {}
func (*BlockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{24}
}
func (m *BlockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockInfo.Merge(dst, src)
}
func (m *BlockInfo) XXX_Size() int {
	return m.Size()
}
func (m *BlockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlockInfo proto.InternalMessageInfo

func (m *BlockInfo) GetHeader() HeaderInfo {
	if m != nil {
		return m.Header
	}
	return HeaderInfo{}
}

func (m *BlockInfo) GetLastCommitInfo() CommitInfo {
	if m != nil {
		return m.LastCommitInfo
	}
	return CommitInfo{}
}

func (m *BlockInfo) GetByzantineValidators() []EvidenceInfo {
	if m != nil {
		return m.ByzantineValidators
	}
	return nil
}

func (m *BlockInfo) GetTxs() []TxInfo {
	if m != nil {
		return m.Txs
	}
	return nil
}

func (*BlockInfo) XXX_MessageName() string {
	return "proto3.BlockInfo"
}

type HeaderInfo struct {
	// basic block info
	BlockHash github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,1,opt,name=block_hash,json=blockHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"block_hash"`
	Version   Version                                               `protobuf:"bytes,2,opt,name=version" json:"version"`
	ChainID   string                                                `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Height    int64                                                 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	Time      time.Time                                             `protobuf:"bytes,5,opt,name=time,stdtime" json:"time"`
	NumTxs    int64                                                 `protobuf:"varint,6,opt,name=num_txs,json=numTxs,proto3" json:"num_txs,omitempty"`
	TotalTxs  int64                                                 `protobuf:"varint,7,opt,name=total_txs,json=totalTxs,proto3" json:"total_txs,omitempty"`
	// prev block info
	LastBlockId []byte `protobuf:"bytes,8,opt,name=last_block_id,json=lastBlockId,proto3" json:"last_block_id,omitempty"`
	// hashes of block data
	LastCommitHash github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,9,opt,name=last_commit_hash,json=lastCommitHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"last_commit_hash"`
	DataHash       github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,10,opt,name=data_hash,json=dataHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"data_hash"`
	// hashes from the app output from the prev block
	ValidatorsHash     github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,11,opt,name=validators_hash,json=validatorsHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"validators_hash"`
	NextValidatorsHash github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,12,opt,name=next_validators_hash,json=nextValidatorsHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"next_validators_hash"`
	ConsensusHash      github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,13,opt,name=consensus_hash,json=consensusHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"consensus_hash"`
	AppHash            github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,14,opt,name=app_hash,json=appHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"app_hash"`
	LastResultsHash    github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,15,opt,name=last_results_hash,json=lastResultsHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"last_results_hash"`
	// consensus info
	EvidenceHash         github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,16,opt,name=evidence_hash,json=evidenceHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"evidence_hash"`
	ProposerAddress      string                                                `protobuf:"bytes,17,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *HeaderInfo) Reset()         { *m = HeaderInfo{} }
func (m *HeaderInfo) String() string { return proto.CompactTextString(m) }
func (*HeaderInfo) ProtoMessage()    {}
func (*HeaderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{25}
}
func (m *HeaderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeaderInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HeaderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderInfo.Merge(dst, src)
}
func (m *HeaderInfo) XXX_Size() int {
	return m.Size()
}
func (m *HeaderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderInfo proto.InternalMessageInfo

func (m *HeaderInfo) GetVersion() Version {
	if m != nil {
		return m.Version
	}
	return Version{}
}

func (m *HeaderInfo) GetChainID() string {
	if m != nil {
		return m.ChainID
	}
	return ""
}

func (m *HeaderInfo) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *HeaderInfo) GetTime() time.Time {
	if m != nil {
		return m.Time
	}
	return time.Time{}
}

func (m *HeaderInfo) GetNumTxs() int64 {
	if m != nil {
		return m.NumTxs
	}
	return 0
}

func (m *HeaderInfo) GetTotalTxs() int64 {
	if m != nil {
		return m.TotalTxs
	}
	return 0
}

func (m *HeaderInfo) GetLastBlockId() []byte {
	if m != nil {
		return m.LastBlockId
	}
	return nil
}

func (m *HeaderInfo) GetProposerAddress() string {
	if m != nil {
		return m.ProposerAddress
	}
	return ""
}

func (*HeaderInfo) XXX_MessageName() string {
	return "proto3.HeaderInfo"
}

type Version struct {
	Block                uint64   `protobuf:"varint,1,opt,name=Block,proto3" json:"Block,omitempty"`
	App                  uint64   `protobuf:"varint,2,opt,name=App,proto3" json:"App,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{26}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(dst, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetBlock() uint64 {
	if m != nil {
		return m.Block
	}
	return 0
}

func (m *Version) GetApp() uint64 {
	if m != nil {
		return m.App
	}
	return 0
}

func (*Version) XXX_MessageName() string {
	return "proto3.Version"
}

type CommitInfo struct {
	BlockHash            github_com_gallactic_gallactic_common_binary.HexBytes `protobuf:"bytes,1,opt,name=block_hash,json=blockHash,proto3,customtype=github.com/gallactic/gallactic/common/binary.HexBytes" json:"block_hash"`
	Votes                []VoteInfo                                            `protobuf:"bytes,2,rep,name=votes" json:"votes"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *CommitInfo) Reset()         { *m = CommitInfo{} }
func (m *CommitInfo) String() string { return proto.CompactTextString(m) }
func (*CommitInfo) ProtoMessage()    {}
func (*CommitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{27}
}
func (m *CommitInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitInfo.Merge(dst, src)
}
func (m *CommitInfo) XXX_Size() int {
	return m.Size()
}
func (m *CommitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CommitInfo proto.InternalMessageInfo

func (m *CommitInfo) GetVotes() []VoteInfo {
	if m != nil {
		return m.Votes
	}
	return nil
}

func (*CommitInfo) XXX_MessageName() string {
	return "proto3.CommitInfo"
}

type VoteInfo struct {
	ValidatorAddress     string    `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	Signature            []byte    `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	Round                int32     `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Height               int64     `protobuf:"varint,4,opt,name=Height,proto3" json:"Height,omitempty"`
	Time                 time.Time `protobuf:"bytes,5,opt,name=time,stdtime" json:"time"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *VoteInfo) Reset()         { *m = VoteInfo{} }
func (m *VoteInfo) String() string { return proto.CompactTextString(m) }
func (*VoteInfo) ProtoMessage()    {}
func (*VoteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{28}
}
func (m *VoteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VoteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteInfo.Merge(dst, src)
}
func (m *VoteInfo) XXX_Size() int {
	return m.Size()
}
func (m *VoteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VoteInfo proto.InternalMessageInfo

func (m *VoteInfo) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *VoteInfo) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *VoteInfo) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *VoteInfo) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *VoteInfo) GetTime() time.Time {
	if m != nil {
		return m.Time
	}
	return time.Time{}
}

func (*VoteInfo) XXX_MessageName() string {
	return "proto3.VoteInfo"
}

type ValidatorInfo struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	PubKey               string   `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	Power                int64    `protobuf:"varint,3,opt,name=power,proto3" json:"power,omitempty"`
	Stake                uint64   `protobuf:"varint,4,opt,name=stake,proto3" json:"stake,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidatorInfo) Reset()         { *m = ValidatorInfo{} }
func (m *ValidatorInfo) String() string { return proto.CompactTextString(m) }
func (*ValidatorInfo) ProtoMessage()    {}
func (*ValidatorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{29}
}
func (m *ValidatorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ValidatorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorInfo.Merge(dst, src)
}
func (m *ValidatorInfo) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorInfo proto.InternalMessageInfo

func (m *ValidatorInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ValidatorInfo) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *ValidatorInfo) GetPower() int64 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *ValidatorInfo) GetStake() uint64 {
	if m != nil {
		return m.Stake
	}
	return 0
}

func (*ValidatorInfo) XXX_MessageName() string {
	return "proto3.ValidatorInfo"
}

type EvidenceInfo struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Height               int64    `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvidenceInfo) Reset()         { *m = EvidenceInfo{} }
func (m *EvidenceInfo) String() string { return proto.CompactTextString(m) }
func (*EvidenceInfo) ProtoMessage()    {}
func (*EvidenceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{30}
}
func (m *EvidenceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvidenceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvidenceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EvidenceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvidenceInfo.Merge(dst, src)
}
func (m *EvidenceInfo) XXX_Size() int {
	return m.Size()
}
func (m *EvidenceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EvidenceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EvidenceInfo proto.InternalMessageInfo

func (m *EvidenceInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EvidenceInfo) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (*EvidenceInfo) XXX_MessageName() string {
	return "proto3.EvidenceInfo"
}

type TxInfo struct {
	Height               int64    `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	Hash                 string   `protobuf:"bytes,2,opt,name=Hash,proto3" json:"Hash,omitempty"`
	GasUsed              int64    `protobuf:"varint,3,opt,name=GasUsed,proto3" json:"GasUsed,omitempty"`
	GasWanted            int64    `protobuf:"varint,4,opt,name=GasWanted,proto3" json:"GasWanted,omitempty"`
	Envelope             string   `protobuf:"bytes,5,opt,name=Envelope,proto3" json:"Envelope,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxInfo) Reset()         { *m = TxInfo{} }
func (m *TxInfo) String() string { return proto.CompactTextString(m) }
func (*TxInfo) ProtoMessage()    {}
func (*TxInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_blockchain_0c91df1782844898, []int{31}
}
func (m *TxInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxInfo.Merge(dst, src)
}
func (m *TxInfo) XXX_Size() int {
	return m.Size()
}
func (m *TxInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TxInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TxInfo proto.InternalMessageInfo

func (m *TxInfo) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *TxInfo) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *TxInfo) GetGasUsed() int64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func (m *TxInfo) GetGasWanted() int64 {
	if m != nil {
		return m.GasWanted
	}
	return 0
}

func (m *TxInfo) GetEnvelope() string {
	if m != nil {
		return m.Envelope
	}
	return ""
}

func (*TxInfo) XXX_MessageName() string {
	return "proto3.TxInfo"
}
func init() {
	proto.RegisterType((*Empty)(nil), "proto3.Empty")
	golang_proto.RegisterType((*Empty)(nil), "proto3.Empty")
	proto.RegisterType((*AddressRequest)(nil), "proto3.AddressRequest")
	golang_proto.RegisterType((*AddressRequest)(nil), "proto3.AddressRequest")
	proto.RegisterType((*AccountResponse)(nil), "proto3.AccountResponse")
	golang_proto.RegisterType((*AccountResponse)(nil), "proto3.AccountResponse")
	proto.RegisterType((*AccountsResponse)(nil), "proto3.AccountsResponse")
	golang_proto.RegisterType((*AccountsResponse)(nil), "proto3.AccountsResponse")
	proto.RegisterType((*ValidatorResponse)(nil), "proto3.ValidatorResponse")
	golang_proto.RegisterType((*ValidatorResponse)(nil), "proto3.ValidatorResponse")
	proto.RegisterType((*ValidatorsResponse)(nil), "proto3.ValidatorsResponse")
	golang_proto.RegisterType((*ValidatorsResponse)(nil), "proto3.ValidatorsResponse")
	proto.RegisterType((*ListAccountsParam)(nil), "proto3.ListAccountsParam")
	golang_proto.RegisterType((*ListAccountsParam)(nil), "proto3.ListAccountsParam")
	proto.RegisterType((*StorageRequest)(nil), "proto3.StorageRequest")
	golang_proto.RegisterType((*StorageRequest)(nil), "proto3.StorageRequest")
	proto.RegisterType((*StorageResponse)(nil), "proto3.StorageResponse")
	golang_proto.RegisterType((*StorageResponse)(nil), "proto3.StorageResponse")
	proto.RegisterType((*StorageItem)(nil), "proto3.StorageItem")
	golang_proto.RegisterType((*StorageItem)(nil), "proto3.StorageItem")
	proto.RegisterType((*StorageAtRequest)(nil), "proto3.StorageAtRequest")
	golang_proto.RegisterType((*StorageAtRequest)(nil), "proto3.StorageAtRequest")
	proto.RegisterType((*StorageAtResponse)(nil), "proto3.StorageAtResponse")
	golang_proto.RegisterType((*StorageAtResponse)(nil), "proto3.StorageAtResponse")
	proto.RegisterType((*ConsensusResponse)(nil), "proto3.ConsensusResponse")
	golang_proto.RegisterType((*ConsensusResponse)(nil), "proto3.ConsensusResponse")
	proto.RegisterType((*ChainResponse)(nil), "proto3.ChainResponse")
	golang_proto.RegisterType((*ChainResponse)(nil), "proto3.ChainResponse")
	proto.RegisterType((*StatusResponse)(nil), "proto3.StatusResponse")
	golang_proto.RegisterType((*StatusResponse)(nil), "proto3.StatusResponse")
	proto.RegisterType((*BlockRequest)(nil), "proto3.BlockRequest")
	golang_proto.RegisterType((*BlockRequest)(nil), "proto3.BlockRequest")
	proto.RegisterType((*BlocksRequest)(nil), "proto3.BlocksRequest")
	golang_proto.RegisterType((*BlocksRequest)(nil), "proto3.BlocksRequest")
	proto.RegisterType((*BlockResponse)(nil), "proto3.BlockResponse")
	golang_proto.RegisterType((*BlockResponse)(nil), "proto3.BlockResponse")
	proto.RegisterType((*BlocksResponse)(nil), "proto3.BlocksResponse")
	golang_proto.RegisterType((*BlocksResponse)(nil), "proto3.BlocksResponse")
	proto.RegisterType((*GenesisResponse)(nil), "proto3.GenesisResponse")
	golang_proto.RegisterType((*GenesisResponse)(nil), "proto3.GenesisResponse")
	proto.RegisterType((*BlockTxsResponse)(nil), "proto3.BlockTxsResponse")
	golang_proto.RegisterType((*BlockTxsResponse)(nil), "proto3.BlockTxsResponse")
	proto.RegisterType((*BlockchainInfoResponse)(nil), "proto3.BlockchainInfoResponse")
	golang_proto.RegisterType((*BlockchainInfoResponse)(nil), "proto3.BlockchainInfoResponse")
	proto.RegisterType((*TxRequest)(nil), "proto3.TxRequest")
	golang_proto.RegisterType((*TxRequest)(nil), "proto3.TxRequest")
	proto.RegisterType((*TxResponse)(nil), "proto3.TxResponse")
	golang_proto.RegisterType((*TxResponse)(nil), "proto3.TxResponse")
	proto.RegisterType((*BlockInfo)(nil), "proto3.BlockInfo")
	golang_proto.RegisterType((*BlockInfo)(nil), "proto3.BlockInfo")
	proto.RegisterType((*HeaderInfo)(nil), "proto3.HeaderInfo")
	golang_proto.RegisterType((*HeaderInfo)(nil), "proto3.HeaderInfo")
	proto.RegisterType((*Version)(nil), "proto3.Version")
	golang_proto.RegisterType((*Version)(nil), "proto3.Version")
	proto.RegisterType((*CommitInfo)(nil), "proto3.CommitInfo")
	golang_proto.RegisterType((*CommitInfo)(nil), "proto3.CommitInfo")
	proto.RegisterType((*VoteInfo)(nil), "proto3.VoteInfo")
	golang_proto.RegisterType((*VoteInfo)(nil), "proto3.VoteInfo")
	proto.RegisterType((*ValidatorInfo)(nil), "proto3.ValidatorInfo")
	golang_proto.RegisterType((*ValidatorInfo)(nil), "proto3.ValidatorInfo")
	proto.RegisterType((*EvidenceInfo)(nil), "proto3.EvidenceInfo")
	golang_proto.RegisterType((*EvidenceInfo)(nil), "proto3.EvidenceInfo")
	proto.RegisterType((*TxInfo)(nil), "proto3.TxInfo")
	golang_proto.RegisterType((*TxInfo)(nil), "proto3.TxInfo")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BlockChainClient is the client API for BlockChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BlockChainClient interface {
	GetAccount(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*AccountResponse, error)
	GetAccounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AccountsResponse, error)
	GetStorage(ctx context.Context, in *StorageRequest, opts ...grpc.CallOption) (*StorageResponse, error)
	GetStorageAt(ctx context.Context, in *StorageAtRequest, opts ...grpc.CallOption) (*StorageAtResponse, error)
	GetValidator(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*ValidatorResponse, error)
	GetValidators(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ValidatorsResponse, error)
	GetStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponse, error)
	GetGenesis(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GenesisResponse, error)
	GetChainID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ChainResponse, error)
	GetLatestBlock(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BlockResponse, error)
	GetConsensusState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConsensusResponse, error)
	GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	GetBlocks(ctx context.Context, in *BlocksRequest, opts ...grpc.CallOption) (*BlocksResponse, error)
	GetBlockchainInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BlockchainInfoResponse, error)
	GetTx(ctx context.Context, in *TxRequest, opts ...grpc.CallOption) (*TxResponse, error)
	GetListTx(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TxInfo, error)
	GetBlockTxs(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockTxsResponse, error)
}

type blockChainClient struct {
	cc *grpc.ClientConn
}

func NewBlockChainClient(cc *grpc.ClientConn) BlockChainClient {
	return &blockChainClient{cc}
}

func (c *blockChainClient) GetAccount(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*AccountResponse, error) {
	out := new(AccountResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetAccounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AccountsResponse, error) {
	out := new(AccountsResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetStorage(ctx context.Context, in *StorageRequest, opts ...grpc.CallOption) (*StorageResponse, error) {
	out := new(StorageResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetStorage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetStorageAt(ctx context.Context, in *StorageAtRequest, opts ...grpc.CallOption) (*StorageAtResponse, error) {
	out := new(StorageAtResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetStorageAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetValidator(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*ValidatorResponse, error) {
	out := new(ValidatorResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetValidators(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ValidatorsResponse, error) {
	out := new(ValidatorsResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetGenesis(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GenesisResponse, error) {
	out := new(GenesisResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetGenesis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetChainID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ChainResponse, error) {
	out := new(ChainResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetChainID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetLatestBlock(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetLatestBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetConsensusState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConsensusResponse, error) {
	out := new(ConsensusResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetConsensusState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetBlocks(ctx context.Context, in *BlocksRequest, opts ...grpc.CallOption) (*BlocksResponse, error) {
	out := new(BlocksResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetBlockchainInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BlockchainInfoResponse, error) {
	out := new(BlockchainInfoResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetBlockchainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetTx(ctx context.Context, in *TxRequest, opts ...grpc.CallOption) (*TxResponse, error) {
	out := new(TxResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetListTx(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TxInfo, error) {
	out := new(TxInfo)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetListTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockChainClient) GetBlockTxs(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockTxsResponse, error) {
	out := new(BlockTxsResponse)
	err := c.cc.Invoke(ctx, "/proto3.BlockChain/GetBlockTxs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlockChainServer is the server API for BlockChain service.
type BlockChainServer interface {
	GetAccount(context.Context, *AddressRequest) (*AccountResponse, error)
	GetAccounts(context.Context, *Empty) (*AccountsResponse, error)
	GetStorage(context.Context, *StorageRequest) (*StorageResponse, error)
	GetStorageAt(context.Context, *StorageAtRequest) (*StorageAtResponse, error)
	GetValidator(context.Context, *AddressRequest) (*ValidatorResponse, error)
	GetValidators(context.Context, *Empty) (*ValidatorsResponse, error)
	GetStatus(context.Context, *Empty) (*StatusResponse, error)
	GetGenesis(context.Context, *Empty) (*GenesisResponse, error)
	GetChainID(context.Context, *Empty) (*ChainResponse, error)
	GetLatestBlock(context.Context, *Empty) (*BlockResponse, error)
	GetConsensusState(context.Context, *Empty) (*ConsensusResponse, error)
	GetBlock(context.Context, *BlockRequest) (*BlockResponse, error)
	GetBlocks(context.Context, *BlocksRequest) (*BlocksResponse, error)
	GetBlockchainInfo(context.Context, *Empty) (*BlockchainInfoResponse, error)
	GetTx(context.Context, *TxRequest) (*TxResponse, error)
	GetListTx(context.Context, *Empty) (*TxInfo, error)
	GetBlockTxs(context.Context, *BlockRequest) (*BlockTxsResponse, error)
}

func RegisterBlockChainServer(s *grpc.Server, srv BlockChainServer) {
	s.RegisterService(&_BlockChain_serviceDesc, srv)
}

func _BlockChain_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetAccount(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetAccounts(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetStorage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetStorage(ctx, req.(*StorageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetStorageAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetStorageAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetStorageAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetStorageAt(ctx, req.(*StorageAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetValidator(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetValidators(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetStatus(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetGenesis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetGenesis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetGenesis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetGenesis(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetChainID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetChainID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetChainID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetChainID(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetLatestBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetLatestBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetLatestBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetLatestBlock(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetConsensusState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetConsensusState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetConsensusState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetConsensusState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetBlock(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetBlocks(ctx, req.(*BlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetBlockchainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetBlockchainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetBlockchainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetBlockchainInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetTx(ctx, req.(*TxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetListTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetListTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetListTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetListTx(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockChain_GetBlockTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockChainServer).GetBlockTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto3.BlockChain/GetBlockTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockChainServer).GetBlockTxs(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BlockChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto3.BlockChain",
	HandlerType: (*BlockChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccount",
			Handler:    _BlockChain_GetAccount_Handler,
		},
		{
			MethodName: "GetAccounts",
			Handler:    _BlockChain_GetAccounts_Handler,
		},
		{
			MethodName: "GetStorage",
			Handler:    _BlockChain_GetStorage_Handler,
		},
		{
			MethodName: "GetStorageAt",
			Handler:    _BlockChain_GetStorageAt_Handler,
		},
		{
			MethodName: "GetValidator",
			Handler:    _BlockChain_GetValidator_Handler,
		},
		{
			MethodName: "GetValidators",
			Handler:    _BlockChain_GetValidators_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _BlockChain_GetStatus_Handler,
		},
		{
			MethodName: "GetGenesis",
			Handler:    _BlockChain_GetGenesis_Handler,
		},
		{
			MethodName: "GetChainID",
			Handler:    _BlockChain_GetChainID_Handler,
		},
		{
			MethodName: "GetLatestBlock",
			Handler:    _BlockChain_GetLatestBlock_Handler,
		},
		{
			MethodName: "GetConsensusState",
			Handler:    _BlockChain_GetConsensusState_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BlockChain_GetBlock_Handler,
		},
		{
			MethodName: "GetBlocks",
			Handler:    _BlockChain_GetBlocks_Handler,
		},
		{
			MethodName: "GetBlockchainInfo",
			Handler:    _BlockChain_GetBlockchainInfo_Handler,
		},
		{
			MethodName: "GetTx",
			Handler:    _BlockChain_GetTx_Handler,
		},
		{
			MethodName: "GetListTx",
			Handler:    _BlockChain_GetListTx_Handler,
		},
		{
			MethodName: "GetBlockTxs",
			Handler:    _BlockChain_GetBlockTxs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/grpc/proto3/blockchain.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Account.Size()))
		n1, err := m.Account.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.BlockHeight))
	}
	if len(m.Accounts) > 0 {
		for _, msg := range m.Accounts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Validator != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Validator.Size()))
		n2, err := m.Validator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.BlockHeight))
	}
	if len(m.Validators) > 0 {
		for _, msg := range m.Validators {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListAccountsParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAccountsParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageItems) > 0 {
		for _, msg := range m.StorageItems {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Key.Size()))
	n3, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Value.Size()))
	n4, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageAtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageAtRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Key.Size()))
	n5, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageAtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageAtResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Key.Size()))
	n6, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Value.Size()))
	n7, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.RoundState.Size()))
	n8, err := m.RoundState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.PeerRoundStates) > 0 {
		for _, msg := range m.PeerRoundStates {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChainName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.ChainName)))
		i += copy(dAtA[i:], m.ChainName)
	}
	if len(m.ChainId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.ChainId)))
		i += copy(dAtA[i:], m.ChainId)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.GenesisHash.Size()))
	n9, err := m.GenesisHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.NodeInfo.Size()))
	n10, err := m.NodeInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.GenesisHash.Size()))
	n11, err := m.GenesisHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.PubKey.Size()))
	n12, err := m.PubKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x22
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.LatestBlockHash.Size()))
	n13, err := m.LatestBlockHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if m.LatestBlockHeight != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.LatestBlockHeight))
	}
	if m.LatestBlockTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.LatestBlockTime))
	}
	if len(m.NodeVersion) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.NodeVersion)))
		i += copy(dAtA[i:], m.NodeVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlocksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.MinHeight))
	}
	if m.MaxHeight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.MaxHeight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Block != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Block.Size()))
		n14, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlocksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenesisResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Genesis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Genesis.Size()))
		n15, err := m.Genesis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockTxsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockTxsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Count))
	}
	if len(m.Txs) > 0 {
		for _, msg := range m.Txs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockchainInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockchainInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastBlockHeight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.LastBlockHeight))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.LastBlockTime)))
	n16, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastBlockTime, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.LastBlockHash.Size()))
	n17, err := m.LastBlockHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.TxHash)))
		i += copy(dAtA[i:], m.TxHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Tx.Size()))
		n18, err := m.Tx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Header.Size()))
	n19, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.LastCommitInfo.Size()))
	n20, err := m.LastCommitInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if len(m.ByzantineValidators) > 0 {
		for _, msg := range m.ByzantineValidators {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Txs) > 0 {
		for _, msg := range m.Txs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HeaderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.BlockHash.Size()))
	n21, err := m.BlockHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x12
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.Version.Size()))
	n22, err := m.Version.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	if len(m.ChainID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.ChainID)))
		i += copy(dAtA[i:], m.ChainID)
	}
	if m.Height != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Height))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)))
	n23, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if m.NumTxs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.NumTxs))
	}
	if m.TotalTxs != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.TotalTxs))
	}
	if len(m.LastBlockId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.LastBlockId)))
		i += copy(dAtA[i:], m.LastBlockId)
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.LastCommitHash.Size()))
	n24, err := m.LastCommitHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	dAtA[i] = 0x52
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.DataHash.Size()))
	n25, err := m.DataHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	dAtA[i] = 0x5a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.ValidatorsHash.Size()))
	n26, err := m.ValidatorsHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	dAtA[i] = 0x62
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.NextValidatorsHash.Size()))
	n27, err := m.NextValidatorsHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	dAtA[i] = 0x6a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.ConsensusHash.Size()))
	n28, err := m.ConsensusHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	dAtA[i] = 0x72
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.AppHash.Size()))
	n29, err := m.AppHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n29
	dAtA[i] = 0x7a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.LastResultsHash.Size()))
	n30, err := m.LastResultsHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.EvidenceHash.Size()))
	n31, err := m.EvidenceHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	if len(m.ProposerAddress) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.ProposerAddress)))
		i += copy(dAtA[i:], m.ProposerAddress)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Block != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Block))
	}
	if m.App != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.App))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(m.BlockHash.Size()))
	n32, err := m.BlockHash.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	if len(m.Votes) > 0 {
		for _, msg := range m.Votes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBlockchain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VoteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ValidatorAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.ValidatorAddress)))
		i += copy(dAtA[i:], m.ValidatorAddress)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Round != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Round))
	}
	if m.Height != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Height))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintBlockchain(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)))
	n33, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n33
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.PubKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.Power != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Power))
	}
	if m.Stake != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Stake))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EvidenceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvidenceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Height != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.Height))
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.GasUsed != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.GasUsed))
	}
	if m.GasWanted != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(m.GasWanted))
	}
	if len(m.Envelope) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBlockchain(dAtA, i, uint64(len(m.Envelope)))
		i += copy(dAtA[i:], m.Envelope)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintBlockchain(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.BlockHeight))
	}
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Validator != nil {
		l = m.Validator.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.BlockHeight))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAccountsParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StorageItems) > 0 {
		for _, e := range m.StorageItems {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageAtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	l = m.Key.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageAtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RoundState.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if len(m.PeerRoundStates) > 0 {
		for _, e := range m.PeerRoundStates {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainName)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	l = m.GenesisHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NodeInfo.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.GenesisHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.PubKey.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.LatestBlockHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.LatestBlockHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.LatestBlockHeight))
	}
	if m.LatestBlockTime != 0 {
		n += 1 + sovBlockchain(uint64(m.LatestBlockTime))
	}
	l = len(m.NodeVersion)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovBlockchain(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.MinHeight))
	}
	if m.MaxHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.MaxHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenesisResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Genesis != nil {
		l = m.Genesis.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockTxsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovBlockchain(uint64(m.Count))
	}
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockchainInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastBlockHeight != 0 {
		n += 1 + sovBlockchain(uint64(m.LastBlockHeight))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastBlockTime)
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.LastBlockHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.LastCommitInfo.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if len(m.ByzantineValidators) > 0 {
		for _, e := range m.ByzantineValidators {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeaderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BlockHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.Version.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = len(m.ChainID)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovBlockchain(uint64(m.Height))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovBlockchain(uint64(l))
	if m.NumTxs != 0 {
		n += 1 + sovBlockchain(uint64(m.NumTxs))
	}
	if m.TotalTxs != 0 {
		n += 1 + sovBlockchain(uint64(m.TotalTxs))
	}
	l = len(m.LastBlockId)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	l = m.LastCommitHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.DataHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.ValidatorsHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.NextValidatorsHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.ConsensusHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.AppHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.LastResultsHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	l = m.EvidenceHash.Size()
	n += 2 + l + sovBlockchain(uint64(l))
	l = len(m.ProposerAddress)
	if l > 0 {
		n += 2 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != 0 {
		n += 1 + sovBlockchain(uint64(m.Block))
	}
	if m.App != 0 {
		n += 1 + sovBlockchain(uint64(m.App))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BlockHash.Size()
	n += 1 + l + sovBlockchain(uint64(l))
	if len(m.Votes) > 0 {
		for _, e := range m.Votes {
			l = e.Size()
			n += 1 + l + sovBlockchain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.Round != 0 {
		n += 1 + sovBlockchain(uint64(m.Round))
	}
	if m.Height != 0 {
		n += 1 + sovBlockchain(uint64(m.Height))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovBlockchain(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.Power != 0 {
		n += 1 + sovBlockchain(uint64(m.Power))
	}
	if m.Stake != 0 {
		n += 1 + sovBlockchain(uint64(m.Stake))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvidenceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovBlockchain(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovBlockchain(uint64(m.Height))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.GasUsed != 0 {
		n += 1 + sovBlockchain(uint64(m.GasUsed))
	}
	if m.GasWanted != 0 {
		n += 1 + sovBlockchain(uint64(m.GasWanted))
	}
	l = len(m.Envelope)
	if l > 0 {
		n += 1 + l + sovBlockchain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBlockchain(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBlockchain(x uint64) (n int) {
	return sovBlockchain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &github_com_gallactic_gallactic_core_account.Account{}
			}
			if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, &AccountResponse{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validator == nil {
				m.Validator = &ValidatorInfo{}
			}
			if err := m.Validator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &ValidatorInfo{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccountsParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccountsParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccountsParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageItems = append(m.StorageItems, StorageItem{})
			if err := m.StorageItems[len(m.StorageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageAtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageAtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageAtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageAtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageAtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageAtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RoundState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRoundStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerRoundStates = append(m.PeerRoundStates, github_com_tendermint_tendermint_consensus_types.PeerRoundState{})
			if err := m.PeerRoundStates[len(m.PeerRoundStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GenesisHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GenesisHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PubKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatestBlockHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockHeight", wireType)
			}
			m.LatestBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBlockHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockTime", wireType)
			}
			m.LatestBlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBlockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHeight", wireType)
			}
			m.MinHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHeight", wireType)
			}
			m.MaxHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockInfo{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, BlockInfo{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Genesis == nil {
				m.Genesis = &github_com_gallactic_gallactic_core_proposal.Genesis{}
			}
			if err := m.Genesis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockTxsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockTxsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockTxsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, TxInfo{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockchainInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockchainInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockchainInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockHeight", wireType)
			}
			m.LastBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlockHeight |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastBlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastBlockHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &TxInfo{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCommitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastCommitInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByzantineValidators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByzantineValidators = append(m.ByzantineValidators, EvidenceInfo{})
			if err := m.ByzantineValidators[len(m.ByzantineValidators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, TxInfo{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTxs", wireType)
			}
			m.NumTxs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTxs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTxs", wireType)
			}
			m.TotalTxs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTxs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastBlockId = append(m.LastBlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.LastBlockId == nil {
				m.LastBlockId = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCommitHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastCommitHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DataHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorsHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValidatorsHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextValidatorsHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextValidatorsHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConsensusHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResultsHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastResultsHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EvidenceHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			m.Block = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Block |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			m.App = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.App |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Votes = append(m.Votes, VoteInfo{})
			if err := m.Votes[len(m.Votes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			m.Stake = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stake |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvidenceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvidenceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvidenceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasWanted", wireType)
			}
			m.GasWanted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasWanted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envelope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Envelope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBlockchain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBlockchain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlockchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBlockchain
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBlockchain
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBlockchain(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBlockchain = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBlockchain   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("rpc/grpc/proto3/blockchain.proto", fileDescriptor_blockchain_0c91df1782844898)
}
func init() {
	golang_proto.RegisterFile("rpc/grpc/proto3/blockchain.proto", fileDescriptor_blockchain_0c91df1782844898)
}

var fileDescriptor_blockchain_0c91df1782844898 = []byte{
	// 2063 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0x4f, 0x73, 0x1b, 0x59,
	0x11, 0xdf, 0x91, 0x25, 0x4b, 0xd3, 0xb2, 0x2c, 0xe9, 0x45, 0x38, 0x8a, 0x70, 0xd9, 0x66, 0xa8,
	0xca, 0x66, 0x21, 0x68, 0x20, 0x66, 0x6b, 0x73, 0x59, 0xc0, 0x72, 0xb2, 0xb6, 0x49, 0x48, 0xcc,
	0x44, 0x18, 0xd8, 0xa2, 0x50, 0x8d, 0xa4, 0x17, 0x79, 0x36, 0xd2, 0xcc, 0x30, 0xf3, 0x64, 0x24,
	0x5c, 0xe6, 0xc0, 0x89, 0x03, 0x54, 0x41, 0x71, 0xe1, 0xc8, 0x89, 0xe2, 0xce, 0x89, 0x03, 0x55,
	0xdc, 0xc8, 0x91, 0x2a, 0x6e, 0x39, 0x18, 0x2a, 0xe1, 0x1b, 0x70, 0xe1, 0x48, 0xbd, 0xbf, 0xf3,
	0x66, 0x8c, 0xd7, 0xd9, 0x8a, 0x38, 0xec, 0xc5, 0xa5, 0xd7, 0xfd, 0xfa, 0xd7, 0xfd, 0xba, 0x7b,
	0xfa, 0x75, 0x3f, 0xc3, 0x56, 0x14, 0x0e, 0xec, 0x11, 0xfd, 0x13, 0x46, 0x01, 0x09, 0xb6, 0xed,
	0xfe, 0x38, 0x18, 0x3c, 0x1b, 0x1c, 0xbb, 0x9e, 0xdf, 0x66, 0x14, 0xb4, 0xcc, 0x19, 0xad, 0x2f,
	0x8d, 0x3c, 0x72, 0x3c, 0xed, 0xb7, 0x07, 0xc1, 0xc4, 0x1e, 0x05, 0xa3, 0x80, 0x0b, 0xf4, 0xa7,
	0x4f, 0xd9, 0x8a, 0x2d, 0xd8, 0x2f, 0x2e, 0xd6, 0x5a, 0x1f, 0x05, 0xc1, 0x68, 0x8c, 0x6d, 0x37,
	0xf4, 0x6c, 0xd7, 0xf7, 0x03, 0xe2, 0x12, 0x2f, 0xf0, 0x63, 0xc1, 0xdd, 0x14, 0x5c, 0x85, 0x41,
	0xbc, 0x09, 0x8e, 0x89, 0x3b, 0x09, 0xf9, 0x06, 0xab, 0x08, 0x85, 0xfb, 0x93, 0x90, 0xcc, 0xad,
	0x2f, 0xc0, 0xea, 0xce, 0x70, 0x18, 0xe1, 0x38, 0x76, 0xf0, 0x8f, 0xa6, 0x38, 0x26, 0xa8, 0x09,
	0x45, 0x41, 0x69, 0x1a, 0x5b, 0xc6, 0x2d, 0xd3, 0x91, 0x4b, 0xeb, 0x0c, 0xaa, 0x3b, 0x83, 0x41,
	0x30, 0xf5, 0x89, 0x83, 0xe3, 0x30, 0xf0, 0x63, 0x8c, 0x3e, 0x82, 0xa2, 0x20, 0xb1, 0xcd, 0xe5,
	0x3b, 0xd7, 0xb9, 0x82, 0xed, 0x76, 0x66, 0x67, 0xe7, 0xbd, 0x17, 0xe7, 0x9b, 0xdb, 0xfa, 0x19,
	0xdd, 0xf1, 0xd8, 0x1d, 0x10, 0x6f, 0xa0, 0xfd, 0x1a, 0x04, 0x11, 0xb6, 0x5d, 0x2e, 0xa8, 0x00,
	0xa4, 0x02, 0xcb, 0x83, 0x9a, 0xf8, 0x19, 0x2b, 0xfd, 0x5b, 0x50, 0xee, 0x50, 0x8f, 0xee, 0x63,
	0x6f, 0x74, 0xcc, 0x6d, 0xc8, 0x3b, 0x3a, 0x09, 0x6d, 0x43, 0x49, 0x4a, 0x35, 0x73, 0x5b, 0x4b,
	0x1f, 0x63, 0xa2, 0xa3, 0x36, 0x5a, 0xfb, 0x50, 0x3f, 0x72, 0xc7, 0xde, 0xd0, 0x25, 0x41, 0xa4,
	0x74, 0x6d, 0x83, 0xa9, 0x88, 0xe2, 0xb4, 0x9f, 0x91, 0x50, 0x8a, 0x71, 0xe0, 0x3f, 0x0d, 0x9c,
	0x64, 0x9f, 0x35, 0x01, 0xa4, 0x16, 0x9f, 0xc4, 0xec, 0x77, 0x01, 0x12, 0x39, 0x61, 0xf8, 0x25,
	0xda, 0xb4, 0x8d, 0xd6, 0x3b, 0x50, 0x7f, 0xe8, 0xc5, 0x44, 0x1e, 0xe4, 0xd0, 0x8d, 0xdc, 0x09,
	0x6a, 0x40, 0xe1, 0xdb, 0x53, 0x1c, 0xcd, 0x45, 0x3c, 0xf9, 0x82, 0x46, 0xfe, 0x09, 0x09, 0x22,
	0x77, 0x84, 0xaf, 0x8e, 0xfc, 0x21, 0x54, 0xd5, 0x5e, 0x71, 0x84, 0xf7, 0x61, 0x45, 0x90, 0x0e,
	0x08, 0x9e, 0x50, 0x09, 0x6a, 0xe2, 0x35, 0x69, 0xa2, 0xc6, 0xeb, 0xe4, 0x9f, 0x9f, 0x6f, 0xbe,
	0xe5, 0xa4, 0xb6, 0x5b, 0x7f, 0x34, 0xa0, 0xac, 0x11, 0xd0, 0x63, 0x58, 0x7a, 0x80, 0xb9, 0x85,
	0x2b, 0x9d, 0xf7, 0xa9, 0xc0, 0x8b, 0xf3, 0xcd, 0x77, 0xaf, 0xcc, 0x97, 0xc9, 0x24, 0xf0, 0xed,
	0xbe, 0xe7, 0xbb, 0xd1, 0xbc, 0xbd, 0x8f, 0x67, 0x9d, 0x39, 0xc1, 0xb1, 0x43, 0x91, 0xd0, 0x13,
	0x28, 0x1c, 0xb9, 0xe3, 0x29, 0x6e, 0xe6, 0x16, 0x01, 0xc9, 0xb1, 0xac, 0x33, 0xa8, 0x09, 0xa3,
	0x77, 0xc8, 0x95, 0x5e, 0x93, 0x67, 0xca, 0x2d, 0xea, 0x4c, 0xd6, 0x9f, 0x0c, 0xa8, 0x6b, 0xfa,
	0x45, 0x24, 0x3e, 0x1d, 0xae, 0xfb, 0x65, 0x0e, 0xea, 0xbb, 0xd4, 0x5e, 0x3f, 0x9e, 0x26, 0x1f,
	0x82, 0x07, 0xe0, 0x04, 0x53, 0x7f, 0xf8, 0x84, 0xb8, 0x04, 0x8b, 0x23, 0x1c, 0x08, 0x7d, 0x3b,
	0x9a, 0x3e, 0x82, 0xfd, 0x21, 0x8e, 0x26, 0x9e, 0x4f, 0xf4, 0x9f, 0x03, 0x89, 0x67, 0x93, 0x79,
	0x88, 0xe3, 0x76, 0x02, 0xf5, 0xc4, 0x9b, 0x84, 0x63, 0xec, 0x68, 0xe0, 0xe8, 0x17, 0x06, 0x54,
	0x0f, 0x31, 0x8e, 0x12, 0x92, 0xfc, 0xae, 0x6e, 0xc8, 0xa4, 0xbd, 0x60, 0x5f, 0x67, 0x4f, 0xd8,
	0xf2, 0xf5, 0x4f, 0x6c, 0x4b, 0x5a, 0x95, 0x93, 0x55, 0x6d, 0xfd, 0xc1, 0x80, 0xca, 0x2e, 0xbd,
	0x07, 0x94, 0x2f, 0xd6, 0xc1, 0x64, 0x84, 0x47, 0xee, 0x04, 0x8b, 0x54, 0x4a, 0x08, 0x34, 0xcd,
	0xd8, 0xe2, 0x60, 0xc8, 0xc2, 0x62, 0x3a, 0x72, 0x89, 0x7a, 0x50, 0xde, 0xc3, 0x3e, 0x8e, 0xbd,
	0x78, 0xdf, 0x8d, 0x8f, 0x9b, 0x4b, 0x8b, 0x08, 0x9a, 0x8e, 0x68, 0xfd, 0x3a, 0x4f, 0x4b, 0x85,
	0x4b, 0xb4, 0xb8, 0x7d, 0x04, 0xa5, 0x47, 0xc1, 0x10, 0xd3, 0xfa, 0x23, 0xa2, 0xf6, 0x48, 0x28,
	0xfc, 0xe0, 0x75, 0x6a, 0xbc, 0xe6, 0xac, 0xc4, 0x83, 0xe1, 0x9d, 0xb0, 0xbd, 0x27, 0x51, 0x1d,
	0x85, 0x9f, 0x3d, 0x5f, 0x6e, 0xd1, 0xe7, 0x43, 0x8f, 0x61, 0xf9, 0x70, 0xda, 0xa7, 0xdf, 0x10,
	0xf7, 0xdd, 0x7b, 0x02, 0xdb, 0xbe, 0x0a, 0x3b, 0x9a, 0x87, 0x24, 0x68, 0x1f, 0x4e, 0xfb, 0x63,
	0x6f, 0xf0, 0x00, 0xcf, 0x1d, 0x01, 0x83, 0x46, 0x50, 0x7d, 0x48, 0x83, 0x4c, 0x78, 0x45, 0xa7,
	0x56, 0xe7, 0x17, 0x61, 0x75, 0x16, 0x15, 0xdd, 0x86, 0xba, 0x4e, 0xe2, 0xb7, 0x49, 0x81, 0xdd,
	0x26, 0x17, 0x19, 0xe8, 0x56, 0xca, 0xac, 0xae, 0x37, 0xc1, 0xcd, 0xe5, 0x2d, 0xe3, 0xd6, 0x92,
	0x93, 0x25, 0xd3, 0xfb, 0x89, 0xba, 0xff, 0x08, 0x47, 0xb1, 0x17, 0xf8, 0xcd, 0x22, 0x4b, 0x38,
	0x9d, 0x64, 0xdd, 0x84, 0x15, 0xb6, 0x5d, 0x56, 0xc1, 0x35, 0x58, 0x3e, 0xd6, 0x2f, 0x33, 0xb1,
	0xb2, 0x1e, 0x40, 0x85, 0xed, 0x53, 0xed, 0xc5, 0x3a, 0x98, 0x13, 0xcf, 0x4f, 0x5d, 0x7c, 0x09,
	0x81, 0x71, 0xdd, 0x99, 0xe0, 0xe6, 0x04, 0x57, 0x12, 0xac, 0xbb, 0x02, 0x4c, 0xa5, 0xe1, 0xdb,
	0x50, 0x60, 0x04, 0x71, 0x1d, 0xd7, 0xe5, 0x87, 0xcc, 0x88, 0x2c, 0x8d, 0x38, 0xdf, 0xda, 0x81,
	0x55, 0x69, 0x86, 0x10, 0xb5, 0x61, 0x99, 0x53, 0xc4, 0xcd, 0x75, 0x51, 0x56, 0xdc, 0x5b, 0x62,
	0x9b, 0xf5, 0x53, 0xa8, 0x8a, 0xa4, 0x51, 0x18, 0xcf, 0xa0, 0x28, 0x48, 0xd9, 0xee, 0x27, 0xb3,
	0xb3, 0x73, 0xf7, 0xc5, 0xf9, 0xe6, 0x57, 0x5f, 0xe7, 0xcb, 0x08, 0xa3, 0x20, 0x0c, 0x62, 0x77,
	0xac, 0x10, 0xa4, 0x06, 0xeb, 0x10, 0x6a, 0x3c, 0x40, 0xb3, 0xc4, 0x80, 0x06, 0x14, 0x76, 0x55,
	0xf3, 0x55, 0x70, 0xf8, 0x02, 0xdd, 0x84, 0xa5, 0xee, 0x4c, 0x16, 0xb7, 0x55, 0x69, 0x52, 0x77,
	0xa6, 0x1d, 0x8a, 0x6e, 0xb0, 0xfe, 0x6d, 0xc0, 0x5a, 0x47, 0xf5, 0xa3, 0xcc, 0x5d, 0x12, 0x98,
	0xa5, 0x4a, 0x3a, 0xad, 0x78, 0xac, 0xb2, 0x64, 0xf4, 0x4d, 0xa8, 0x28, 0x12, 0x4b, 0xa9, 0x1c,
	0xf3, 0x44, 0xab, 0xcd, 0x5b, 0xd0, 0xb6, 0x6c, 0x41, 0xdb, 0x5d, 0xd9, 0x82, 0x76, 0x4a, 0xd4,
	0x84, 0x5f, 0xfd, 0x63, 0xd3, 0x70, 0xd2, 0xa2, 0x68, 0xa0, 0x61, 0x2d, 0xae, 0x96, 0xa5, 0x31,
	0xad, 0xcf, 0x83, 0xd9, 0x9d, 0x69, 0x69, 0xdb, 0x9d, 0x31, 0x55, 0xbc, 0xe0, 0x8a, 0x95, 0x75,
	0x1b, 0x80, 0x6e, 0x12, 0xde, 0xd8, 0x80, 0x5c, 0x77, 0x26, 0x42, 0x9c, 0xf1, 0xa7, 0x93, 0xeb,
	0xce, 0xac, 0xff, 0x18, 0x60, 0xaa, 0xb4, 0x41, 0x5f, 0xa6, 0x9f, 0x82, 0x3b, 0xc4, 0xb2, 0x49,
	0x44, 0x52, 0x62, 0x9f, 0x51, 0xf5, 0xd4, 0xe2, 0xfb, 0x50, 0x07, 0x6a, 0x63, 0x37, 0x26, 0x3d,
	0x7a, 0x00, 0x8f, 0xf4, 0x3c, 0x5a, 0x55, 0x73, 0x69, 0xd9, 0x5d, 0xc6, 0xd2, 0x64, 0x57, 0xa9,
	0x44, 0x42, 0x45, 0xdf, 0x82, 0x46, 0x7f, 0xfe, 0x13, 0xd7, 0x27, 0x9e, 0x8f, 0x7b, 0x27, 0x49,
	0xeb, 0xb8, 0xc4, 0xb2, 0xa0, 0x21, 0x71, 0xee, 0x9f, 0x78, 0x43, 0xec, 0x0f, 0xb0, 0x86, 0x74,
	0x4d, 0xc9, 0x25, 0x8d, 0xa4, 0xcc, 0xa1, 0xfc, 0x55, 0x39, 0xf4, 0x57, 0x13, 0x20, 0x39, 0x17,
	0xfa, 0x01, 0x00, 0x9b, 0x70, 0x7a, 0xc7, 0xd2, 0xa7, 0x6f, 0x1c, 0x3e, 0xb3, 0xaf, 0xca, 0x9d,
	0x0d, 0xc5, 0x13, 0x51, 0x92, 0xb8, 0x7b, 0xaa, 0xaa, 0x23, 0xe6, 0x64, 0x61, 0x99, 0xdc, 0x85,
	0x6e, 0x42, 0x89, 0xe5, 0x76, 0xcf, 0x1b, 0xb2, 0x5c, 0x32, 0x3b, 0xe5, 0x97, 0xe7, 0x9b, 0xe2,
	0xe6, 0xbc, 0xe7, 0x14, 0x07, 0xe2, 0x0a, 0x4d, 0xaa, 0x57, 0x9e, 0x15, 0x44, 0xb1, 0x42, 0x77,
	0x21, 0x4f, 0x27, 0x27, 0x56, 0x52, 0x5f, 0x37, 0xa7, 0x99, 0x04, 0xba, 0x0e, 0x45, 0x7f, 0x3a,
	0xe9, 0x91, 0x59, 0x2c, 0x6a, 0xec, 0xb2, 0x3f, 0x9d, 0x74, 0x67, 0x31, 0xfa, 0x2c, 0x98, 0x24,
	0x20, 0xee, 0x98, 0xb1, 0x8a, 0x8c, 0x55, 0x62, 0x04, 0xca, 0xb4, 0xa0, 0xc2, 0x12, 0x81, 0xfb,
	0xd0, 0x1b, 0x36, 0x4b, 0xd4, 0x83, 0x4e, 0x79, 0x2c, 0x33, 0xf8, 0x60, 0x88, 0x46, 0xe9, 0x64,
	0x61, 0x8e, 0x36, 0x17, 0xe1, 0x68, 0x2d, 0xa3, 0x98, 0xb7, 0x3f, 0x04, 0x73, 0xe8, 0x12, 0x97,
	0x6b, 0x80, 0x45, 0x68, 0x28, 0x51, 0x3c, 0x86, 0xfd, 0x14, 0xaa, 0x49, 0x8e, 0x72, 0x0d, 0xe5,
	0x85, 0x9c, 0x21, 0x41, 0x65, 0x7a, 0x02, 0x68, 0xf8, 0x78, 0x46, 0x7a, 0x59, 0x65, 0x2b, 0x8b,
	0x50, 0x86, 0x28, 0xf4, 0x51, 0x5a, 0xe1, 0x10, 0x56, 0x55, 0x73, 0xc3, 0x55, 0x55, 0x16, 0x52,
	0xc3, 0x14, 0x28, 0xd3, 0xf2, 0x3d, 0x28, 0xb9, 0x61, 0xc8, 0xf1, 0x57, 0x17, 0x81, 0x5f, 0x74,
	0xc3, 0x90, 0x21, 0x7b, 0x50, 0x67, 0xd9, 0x15, 0xe1, 0x78, 0x3a, 0x26, 0xe2, 0x08, 0xd5, 0x85,
	0x34, 0x2f, 0x14, 0xd7, 0xe1, 0xb0, 0x4c, 0x55, 0x1f, 0x2a, 0x58, 0x54, 0x23, 0xae, 0xa6, 0xb6,
	0x08, 0x35, 0x2b, 0x12, 0x93, 0xe9, 0x78, 0x07, 0x6a, 0xfc, 0x46, 0xc5, 0x51, 0xcf, 0x15, 0x53,
	0x5a, 0x9d, 0x55, 0xfa, 0xaa, 0xa4, 0xcb, 0x19, 0xf7, 0x2b, 0x50, 0x14, 0x55, 0x84, 0x5e, 0xab,
	0x49, 0x5b, 0x91, 0x17, 0x3d, 0x04, 0xaa, 0xc1, 0xd2, 0x4e, 0x18, 0x8a, 0xae, 0x84, 0xfe, 0xb4,
	0x7e, 0x6b, 0x00, 0x68, 0x25, 0xf8, 0xff, 0x5b, 0xfc, 0x6e, 0x43, 0xe1, 0x24, 0x48, 0x86, 0x96,
	0x9a, 0x2a, 0x7d, 0x01, 0xd1, 0xab, 0x39, 0xdf, 0x64, 0xfd, 0xd9, 0x80, 0x92, 0xe4, 0xa0, 0x2f,
	0x42, 0x5d, 0x7d, 0x00, 0xca, 0x0d, 0xfc, 0xc2, 0xab, 0x29, 0x86, 0x9c, 0x5a, 0xd7, 0xc1, 0x8c,
	0xbd, 0x91, 0xef, 0x92, 0x69, 0x24, 0x26, 0x40, 0x27, 0x21, 0x50, 0xd7, 0x44, 0x74, 0x8a, 0x61,
	0xe5, 0xb4, 0xe0, 0xf0, 0x05, 0xad, 0x9f, 0xfb, 0xa9, 0xfa, 0xb9, 0xff, 0x86, 0xf5, 0xd3, 0xf2,
	0xa1, 0x92, 0x7a, 0xe5, 0xa0, 0xf3, 0x4f, 0xda, 0x72, 0xb9, 0xa4, 0xa5, 0x36, 0x9c, 0xf6, 0x7b,
	0xcf, 0xc4, 0xa8, 0x6d, 0x3a, 0xcb, 0x21, 0x6f, 0xc3, 0x1b, 0x50, 0x08, 0x83, 0x1f, 0xe3, 0x88,
	0xd9, 0xba, 0xe4, 0xf0, 0x05, 0xa5, 0xc6, 0xc4, 0x7d, 0x86, 0x99, 0xa9, 0x79, 0x87, 0x2f, 0xac,
	0x6f, 0xc0, 0x8a, 0x7e, 0x35, 0x7e, 0x8c, 0xba, 0xe4, 0xae, 0xc8, 0xe9, 0x77, 0x85, 0xf5, 0x73,
	0x83, 0xf6, 0x12, 0x4c, 0x38, 0x71, 0x87, 0x91, 0x72, 0x07, 0x82, 0xbc, 0x1a, 0x61, 0x4c, 0x87,
	0xfd, 0xa6, 0x8a, 0xf6, 0xdc, 0xf8, 0x3b, 0x31, 0x1e, 0x0a, 0x33, 0xe5, 0x92, 0x06, 0x62, 0xcf,
	0x8d, 0xbf, 0xeb, 0xfa, 0x04, 0x0f, 0x85, 0x5f, 0x13, 0x02, 0x6a, 0x41, 0xe9, 0xbe, 0x7f, 0x82,
	0xc7, 0x41, 0xc8, 0xdd, 0x6b, 0x3a, 0x6a, 0x7d, 0xe7, 0xf7, 0x65, 0x00, 0x96, 0xb3, 0xec, 0xa2,
	0x43, 0xdf, 0x07, 0xd8, 0xc3, 0xf2, 0x4d, 0x08, 0xad, 0xa9, 0xe7, 0xaf, 0xd4, 0xbb, 0x5f, 0xeb,
	0xb2, 0x67, 0x31, 0xab, 0xf5, 0xb3, 0xbf, 0xff, 0xeb, 0x37, 0xb9, 0x06, 0x42, 0xb6, 0xe0, 0xd8,
	0xa7, 0x42, 0xf4, 0x0c, 0x1d, 0xd0, 0xd9, 0x4c, 0x3d, 0x37, 0xa1, 0x8a, 0x6a, 0x33, 0x26, 0x21,
	0x99, 0xb7, 0x9a, 0x19, 0x48, 0xd5, 0xb8, 0x5a, 0x75, 0x86, 0x59, 0x46, 0xa6, 0xad, 0x64, 0xb9,
	0x95, 0xe2, 0x79, 0x23, 0xb1, 0x32, 0xfd, 0x46, 0x95, 0x58, 0x99, 0x79, 0x8f, 0xd2, 0xac, 0x14,
	0x1c, 0xcd, 0xca, 0x11, 0xac, 0x24, 0xd0, 0x3b, 0x04, 0x35, 0x33, 0x20, 0xea, 0x31, 0xa7, 0x75,
	0xe3, 0x7f, 0x70, 0x84, 0x02, 0x8b, 0x29, 0x58, 0x47, 0x2d, 0x5b, 0xf1, 0x12, 0x15, 0xf6, 0xe9,
	0x03, 0x3c, 0x3f, 0x43, 0x3d, 0xa6, 0x48, 0x25, 0xee, 0xa5, 0xbe, 0xbe, 0x71, 0xe1, 0x25, 0x4f,
	0xa9, 0x59, 0x67, 0x6a, 0xd6, 0x50, 0xc3, 0x56, 0x3c, 0xed, 0x24, 0x8f, 0xa1, 0xa2, 0x2b, 0xb8,
	0xe0, 0xf1, 0xd6, 0x05, 0xe0, 0xc4, 0xe7, 0xd7, 0x18, 0x72, 0x05, 0x95, 0x6d, 0x4d, 0x7e, 0x17,
	0x4c, 0xe6, 0x1a, 0x3a, 0xdd, 0x67, 0xc1, 0xb4, 0x18, 0xe8, 0xc3, 0xbf, 0x55, 0x65, 0x40, 0x26,
	0x2a, 0xda, 0x42, 0xee, 0x03, 0x16, 0x3a, 0x31, 0xa8, 0x64, 0x51, 0x2e, 0x9b, 0x89, 0xac, 0x1a,
	0x83, 0x01, 0x54, 0xb2, 0xa5, 0xe4, 0x3d, 0x86, 0x23, 0xba, 0xb3, 0x2c, 0x8e, 0x7a, 0xfd, 0x4c,
	0xbd, 0x9a, 0x68, 0x28, 0x52, 0xee, 0x21, 0xac, 0xee, 0x61, 0xa2, 0x8d, 0xb4, 0x97, 0x22, 0xa5,
	0x86, 0x49, 0xab, 0xc1, 0x90, 0x56, 0xd1, 0x8a, 0xad, 0xcb, 0x1e, 0x41, 0x9d, 0xda, 0x24, 0xaf,
	0x5f, 0xfe, 0x96, 0x94, 0x01, 0xbc, 0xfc, 0x01, 0xc9, 0xba, 0xce, 0x40, 0xeb, 0xa8, 0x6a, 0x67,
	0x20, 0x0e, 0xa1, 0xb4, 0x87, 0x85, 0x8e, 0x46, 0xc6, 0x20, 0x9e, 0x24, 0x97, 0x98, 0x99, 0x20,
	0x32, 0xba, 0x7d, 0xca, 0xeb, 0xcf, 0x19, 0x1a, 0xb0, 0x50, 0xf2, 0x69, 0x15, 0xa5, 0x85, 0x55,
	0xe2, 0xad, 0x65, 0xc9, 0x02, 0xf4, 0x6d, 0x06, 0xfa, 0x39, 0xb4, 0xc9, 0x41, 0x63, 0xfb, 0x54,
	0xcd, 0xe4, 0x67, 0xf6, 0xa9, 0x9a, 0xc0, 0xcf, 0xd0, 0x0f, 0x99, 0x3b, 0xd2, 0x53, 0x63, 0xd6,
	0x1d, 0x1b, 0x29, 0x25, 0x17, 0x86, 0x4b, 0xed, 0x53, 0xbd, 0x08, 0x75, 0x0f, 0x0a, 0x7b, 0x98,
	0x74, 0x67, 0xa8, 0x9e, 0xcc, 0x1c, 0xd2, 0x78, 0xa4, 0x93, 0x2e, 0x04, 0xad, 0x3b, 0xb3, 0x4f,
	0xf9, 0xf4, 0x76, 0x86, 0xbe, 0xc6, 0x5c, 0xf1, 0xd0, 0x8b, 0x29, 0x52, 0xc6, 0xba, 0xcc, 0x30,
	0x63, 0x21, 0x86, 0xb0, 0x82, 0xc0, 0x4e, 0x44, 0x9e, 0xb2, 0xb2, 0x26, 0xc7, 0xed, 0x4b, 0xe2,
	0xd3, 0x4c, 0x51, 0xb5, 0xb1, 0x5c, 0x79, 0xd3, 0xb4, 0x25, 0xeb, 0x43, 0x7a, 0x5a, 0xb9, 0x50,
	0x21, 0xeb, 0x34, 0x9f, 0xbf, 0xdc, 0x30, 0xfe, 0xf6, 0x72, 0xc3, 0xf8, 0xe7, 0xcb, 0x0d, 0xe3,
	0x77, 0xaf, 0x36, 0xde, 0xfa, 0xcb, 0xab, 0x0d, 0xe3, 0xf9, 0xab, 0x0d, 0xa3, 0x2f, 0xfe, 0x2d,
	0xf4, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x95, 0xc3, 0x16, 0x41, 0x1a, 0x00, 0x00,
}
